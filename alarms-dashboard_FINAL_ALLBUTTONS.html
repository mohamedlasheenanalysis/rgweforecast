<!--
  Offline Turbine Alarms Dashboard
  نسخة عربية بالكامل تعرض الإنذارات حسب التوربين وتتيح تصفية حسب الفئة والزمن.

  هذه الصفحة لا تعتمد على أية مكتبات خارجية أو اتصال بالإنترنت لقراءة ملفات CSV.
  لقراءة ملفات Excel (XLS/XLSX) يتم تحميل مكتبة SheetJS (XLSX.js) تلقائياً عند توفر اتصال
  بالإنترنت. إذا كنت غير متصل، ستظهر رسالة تطلب حفظ الملف كـ CSV.

  Author: ChatGPT
-->
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8" />
  <title>AWS Analysis</title>
  <style>

/* AWS Analysis heading style */
.panel-title {
  color: var(--accent);
  font-weight: 800;
  letter-spacing: .015em;
}



/* Reserve top space for header */
.sidebar, .content { padding-top: 78px !important; }



/* Fixed header for logo */
#page-header { position: fixed; left: 0; right: 0; top: 0; height: 64px;
  display: flex; align-items: center;
  padding: 0 10px;
  background: rgba(255,255,255,.94);
  border-bottom: 1px solid var(--border);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  z-index: 450;
}
#page-header .brand { display:flex; align-items:center; gap:8px; }
#page-header img { max-height: 48px; height: 48px; width: auto; object-fit: contain; }



/* Footer refinements */
#page-footer { height: 36px; }
#page-footer .credit { font-size: 12px; gap: 6px; }



/* Global footer credit (bottom, integrated) */
#page-footer {
  position: fixed;
  left: 0; right: 0; bottom: 0;
  height: 46px;
  display: flex; align-items: center; justify-content: center;
  background: rgba(255,255,255,.92);
  border-top: 1px solid var(--border);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  z-index: 400;
}
#page-footer .credit {
  display: inline-flex; align-items: center; gap: 8px;
  font-size: 12.5px; color: var(--muted);
}
#page-footer .credit .dot {
  width: 8px; height: 8px; border-radius: 999px;
  background: var(--accent);
  box-shadow: 0 0 0 3px rgba(14,165,233,.18);
}
#page-footer .credit strong { color: var(--text); font-weight: 700; letter-spacing: .01em; }

/* Reserve space so footer doesn't cover content */
.sidebar, .content { padding-bottom: 56px !important; }



/* Designer credit badge */
.sidebar { position: relative; padding-bottom: 70px; }
#credit-badge {
  position: absolute;
  right: 12px;
  bottom: 12px;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  font-size: 12.5px;
  color: var(--muted);
  background: rgba(255,255,255,.75);
  border: 1px solid var(--border);
  border-radius: 999px;
  box-shadow: 0 8px 22px rgba(2,6,23,.08);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}
#credit-badge .dot {
  width: 8px; height: 8px;
  border-radius: 999px;
  background: var(--accent);
  box-shadow: 0 0 0 3px rgba(14,165,233,.18);
}
#credit-badge strong { color: var(--text); font-weight: 700; letter-spacing: .01em; }



/* Chart polish */
#analysis-section {
  padding: 14px !important;
  border-radius: 16px !important;
}
#analysis-section canvas {
  border-radius: 12px;
}



/* === Polished light theme (CSS-only, safe) === */
:root {
  --bg: #f7f8fb;
  --panel: #ffffff;
  --sidebar: #eaf4ff;
  --text: #0f172a;
  --muted: #475569;
  --accent: #0ea5e9;
  --accent-contrast: #ffffff;
  --border: #e5e7eb;
  --chip: #eef2ff;
}
html, body { background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
.sidebar { background: var(--sidebar) !important; color: var(--text) !important; }
.content { background: var(--panel) !important; border: 1px solid var(--border); border-radius: 12px; box-shadow: 0 10px 24px rgba(2,6,23,.06); }

/* Inputs */
.filter-section input[type="text"],
.filter-section input[type="date"],
.filter-section input[type="time"] {
  background: var(--panel) !important;
  color: var(--text) !important;
  border: 1px solid var(--border) !important;
  padding: 8px 10px !important;
  border-radius: 10px !important;
  outline: none;
  transition: box-shadow .15s ease, border-color .15s ease;
}
.filter-section input::placeholder { color: var(--muted); opacity: .9; }
.filter-section input:focus { border-color: var(--accent); box-shadow: 0 0 0 4px rgba(14,165,233,.2); }

/* Event list pills */
.event-list { padding: 6px; }
.event-item {
  background: var(--chip) !important;
  color: var(--text) !important;
  border: 1px solid var(--border) !important;
  border-radius: 12px !important;
  padding: 8px 10px !important;
  transition: transform .1s ease, box-shadow .2s ease, background .2s ease;
}
.event-item:hover { transform: translateY(-1px); box-shadow: 0 8px 18px rgba(2,6,23,.08); }
.event-item.selected {
  background: var(--accent) !important;
  color: var(--accent-contrast) !important;
  border-color: transparent !important;
  box-shadow: 0 8px 20px rgba(14,165,233,.35);
}

/* Buttons */
button {
  border: 1px solid var(--border) !important;
  background: linear-gradient(to bottom, rgba(255,255,255,.95), rgba(245,246,250,.95)) !important;
  color: var(--text) !important;
  padding: 8px 12px !important;
  border-radius: 10px !important;
  cursor: pointer;
  font-weight: 600;
  transition: transform .1s ease, box-shadow .2s ease, border-color .15s ease;
}
button:hover { transform: translateY(-1px); box-shadow: 0 12px 24px rgba(2,6,23,.10); border-color: var(--accent); }
button:active { transform: translateY(0); box-shadow: none; }
#export-btn, #export-excel-btn, 
#analysis-img-btn, #analysis-pdf-btn { display: none; } /* intentionally removed auto-hide for robust visibility */

/* Table styling */
#table-container table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  overflow: hidden;
  border-radius: 12px;
  box-shadow: 0 10px 24px rgba(2,6,23,.06);
}

#table-container thead th.sortable-th { user-select: none; }
#table-container thead th.sortable-th:hover { filter: brightness(1.05); }

#table-container thead th {
  position: sticky; top: 0;
  background: #0f172a !important;  /* deep navy header */
  color: #ffffff !important;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .04em;
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
}
#table-container tbody td {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  vertical-align: middle;
  background: var(--panel);
  color: var(--text);
}
#table-container tbody tr:nth-child(even) { background: rgba(2,6,23,.03); }
#table-container tbody tr:hover { background: rgba(14,165,233,.10); }
#table-container tbody td:nth-child(5),
#table-container tbody td:nth-child(6) { text-align: right; font-variant-numeric: tabular-nums; }

/* Metrics chips */
.metrics { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:8px; }
.metric {
  background: var(--chip) !important;
  color: var(--text) !important;
  border: 1px solid var(--border) !important;
  border-radius: 999px !important;
  padding: 6px 10px !important;
  box-shadow: 0 2px 8px rgba(2,6,23,.06);
}
.metric span { opacity:.8; margin-inline-end:4px; }
.metric strong { font-variant-numeric: tabular-nums; }

/* Chart canvas frame */
#analysis-section { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 10px; box-shadow: 0 10px 24px rgba(2,6,23,.06); }
#selected-event-title { font-size: 18px; font-weight: 800; letter-spacing: .015em; margin: 10px 0; }

/* Scrollbars */
* { scrollbar-width: thin; scrollbar-color: rgba(100,116,139,.6) transparent; }
*::-webkit-scrollbar { width: 10px; height: 10px; }
*::-webkit-scrollbar-track { background: transparent; }
*::-webkit-scrollbar-thumb { background: rgba(100,116,139,.5); border-radius: 10px; border: 2px solid transparent; background-clip: padding-box; }
*::-webkit-scrollbar-thumb:hover { background: rgba(100,116,139,.8); }


/* === Metrics bar above the analysis chart === */
.metrics {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  align-items: center;
  margin-bottom: 6px;
}
.metric {
  background: var(--sidebar-color);
  border: 1px solid var(--accent-color);
  border-radius: 6px;
  padding: 6px 8px;
  font-size: 13px;
}
.metric span {
  opacity: 0.8;
  margin-inline-end: 4px;
}

    :root {
      /* ألوان مستوحاة من الصورة المرفقة: مزيج بين الأزرق الداكن والأبيض والأزرق الفاتح */
      --bg-color: #ffffff;
      --sidebar-color: #e6f2fa;
      --accent-color: #00a5e3;
      --text-color: #000000;
      --highlight-color: #8dd7f8;
      --error-bg: #fdecea;
      --error-text: #b00020;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: row-reverse;
      height: 100vh;
      /* خلفية بيضاء للموقع كما هو مطلوب */
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: system-ui, sans-serif;
      overflow: hidden;
    }
    .sidebar {
      width: 280px;
      max-width: 100%;
      background-color: var(--sidebar-color);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
    }
    .content {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
      /* اجعل خلفية منطقة المحتوى بيضاء حتى لا يتأثر بالتدرج في الـbody */
      background-color: var(--bg-color);
      border-radius: 8px;
    }
    h1, h2, h3 {
      margin: 0 0 8px 0;
      font-weight: 600;
    }
    h1 {
      font-size: 20px;
    }
    h2 {
      font-size: 18px;
    }
    h3 {
      font-size: 16px;
    }
    .message {
      padding: 8px;
      border-radius: 4px;
      background-color: var(--error-bg);
      color: var(--error-text);
      display: none;
      font-size: 14px;
    }
    .filter-section {
      margin-bottom: 12px;
    }
    .filter-section label {
      display: block;
      margin-bottom: 4px;
      font-size: 14px;
    }
    .filter-section input[type="date"],
    .filter-section input[type="time"] {
      width: 100%;
      padding: 4px;
      border-radius: 4px;
      border: none;
      background-color: var(--accent-color);
      color: var(--text-color);
    }
    .quick-buttons button {
      margin: 2px;
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      background-color: var(--accent-color);
      color: var(--text-color);
      cursor: pointer;
      font-size: 12px;
    }
    .quick-buttons button:hover {
      background-color: var(--highlight-color);
    }
    .category-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 120px;
      overflow-y: auto;
    }
    .category-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 14px;
    }
    .event-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 300px;
      overflow-y: auto;
      direction: ltr; /* عرض عناصر قائمة الإنذارات من اليسار لليمين لتجنب انزلاق النص خارج الحاوية في الوضع RTL */
    }
    .event-item {
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      background-color: var(--accent-color);
      color: var(--text-color);
      font-size: 14px;
      /* السماح بظهور النص بالكامل داخل عنصر الإنذار حتى وإن كان طويلاً */
      white-space: normal;
      overflow-wrap: anywhere;
      direction: ltr; /* عرض أسماء الإنذارات من اليسار لليمين حتى لا تختفي النصوص في الوضع RTL */
      text-align: left;
    }
    .event-item.selected {
      background-color: var(--highlight-color);
      font-weight: bold;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 14px;
    }
    th, td {
      padding: 8px;
      border: 1px solid var(--accent-color);
      text-align: left;
      /* Set direction to left-to-right since the table is now fully in English */
      direction: ltr;
    }
    th {
      background-color: var(--accent-color);
    }
    #export-btn {
      align-self: flex-start;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background-color: var(--accent-color);
      color: var(--text-color);
      cursor: pointer;
      font-size: 14px;
    }
    #export-btn:hover {
      background-color: var(--highlight-color);
    }
    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    ::-webkit-scrollbar-track {
      background: var(--sidebar-color);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--accent-color);
      border-radius: 3px;
    }

    /* Logo container inside content: display flex and allow wrapping */
    #logo-container {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: 16px;
      width: 100%;
    }
    #logo-container img {
      max-width: 150px;
      height: auto;
    }
    #logo-container #selected-event-title {
      margin-top: 4px;
      font-size: 16px;
      font-weight: 600;
      color: var(--text-color);
      max-width: 100%;
      white-space: normal;
      word-break: break-word;
    }
  </style>
</head>
<body>
<header id="page-header"><div class="brand"><!-- Use the provided logo image from the same directory.  It will scale down automatically. -->
      <!-- Embed the logo image directly using a base64 data URI to ensure it always displays correctly -->
      <img src="data:image/jpeg;base64,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" alt="Ras Ghareb Wind Energy Logo" />
      <!-- This element will be updated dynamically to show the selected alarm name -->
      <h2 id="selected-event-title"></h2></div></header>

  <!-- Logo container will be placed inside the content for scrollable behaviour -->
  <div class="sidebar">
    <!-- تمت إزالة الشعار القديم. سيتم عرض الشعار الجديد في أعلى يسار الموقع -->
    <h1><span class="panel-title">AWS Analysis</span></h1>
    <input type="file" id="file-input" accept=".csv,.txt,.xls,.xlsx" />
    <div id="message" class="message"></div>
    <div id="filters" style="display:none;">
      <div class="filter-section">
        <h3>Category Filter</h3>
        <div id="category-filters" class="category-list"></div>
      </div>
      <div class="filter-section">
        <h3>Time Filter</h3>
        <label>From (Date):
          <input type="date" id="start-date" />
        </label>
        <label>To (Date):
          <input type="date" id="end-date" />
        </label>
        <label>From (Time):
          <!-- Use 24-hour format by default by specifying the value -->
          <input type="time" id="start-time" value="00:00" />
        </label>
        <label>To (Time):
          <!-- Set the default value to the end of the day -->
          <input type="time" id="end-time" value="23:59" />
        </label>
        <div class="quick-buttons">
          <button id="today-btn">Today</button>
          <button id="yesterday-btn">Yesterday</button>
          <button id="last24-btn">Last 24 hours</button>
          <button id="clear-filter-btn">Clear filter</button>
        </div>
      </div>
      
<div class="filter-section">
  <h3>Filter by Turbine</h3>
  <input type="text" id="device-filter" placeholder="Type turbine number/name (e.g., 5 or WTG-05)" style="width:100%; padding:4px; border-radius:4px; border:none; background-color: var(--accent-color); color: var(--text-color); margin-bottom:4px;" />
  <div class="quick-buttons">
    <button id="clear-device-filter-btn">Clear turbine</button>
  </div>
</div>
<div class="filter-section">
        <h3>Alarm List</h3>
        <!-- مربع البحث عن الإنذارات -->
        <input type="text" id="event-search" placeholder="Search for alarm..." style="width:100%; padding:4px; border-radius:4px; border:none; background-color: var(--accent-color); color: var(--text-color); margin-bottom:4px;" />
        <div id="event-list" class="event-list"></div>
      </div>
    </div>
    <!-- فقرة لعرض اسم المصمم -->
    
    <!-- أيقونة توربين رياح لإضافة مظهر طاقة الرياح -->
    <div style="margin-top:12px; text-align:center;">
      <svg width="60" height="80" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
        <!-- برج التوربين -->
        <rect x="31" y="32" width="2" height="28" fill="var(--text-color)" />
        <!-- المحور -->
        <circle cx="32" cy="32" r="3" fill="var(--text-color)" />
        <!-- الريش الثلاثة -->
        <line x1="32" y1="32" x2="32" y2="16" stroke="var(--accent-color)" stroke-width="2" />
        <line x1="32" y1="32" x2="44" y2="42" stroke="var(--accent-color)" stroke-width="2" />
        <line x1="32" y1="32" x2="20" y2="42" stroke="var(--accent-color)" stroke-width="2" />
      </svg>
    </div>
  </div>
  <div class="content">
    <!-- Logo and selected alarm name container (scrolls with the page) -->
    
    <div id="table-container"></div>
    <!-- أزرار التصدير للجدول -->
    <div style="display:flex; flex-wrap: wrap; gap:8px; margin-top:8px;">
      <button id="export-btn" style="display:none;">Export table (CSV)</button>
      <button id="export-excel-btn" style="display:none;">Export table (Excel)</button>
      <button id="export-pdf-btn" style="display:none;">Export table (PDF)</button>
    </div>

    <!-- قسم التحليل لأعلى التوربينات حسب إجمالي المدة -->
    <div id="analysis-section" style="display:none; margin-top:24px;">
      <!-- Heading removed to keep chart only -->
      <!-- الرسم البياني -->
      <!-- صغر حجم الرسم البياني للملاءمة -->
      <div id="chart-metrics" class="metrics">
  <div class="metric"><span>Alarm Name:</span> <strong id="metric-alarm">—</strong></div>
  <div class="metric"><span>Occurrences:</span> <strong id="metric-count">0</strong></div>
  <div class="metric"><span>Total Duration:</span> <strong id="metric-duration">00:00</strong></div>
</div>

      <canvas id="analysis-chart" style="width:100%; max-width:100%; height:200px; max-height:200px;"></canvas>
      <!-- جدول التحليل -->
      <div id="analysis-table-container" style="margin-top:12px;"></div>
      <!-- أزرار تصدير التحليل -->
      <div style="display:flex; flex-wrap: wrap; gap:8px; margin-top:8px;">
        <button id="analysis-img-btn" style="display:none;">Export analysis (Image)</button>
        <button id="analysis-pdf-btn" style="display:none;">Export analysis (PDF)</button>
      </div>
    </div>
  </div>
  <script>
    // بيانات التحميل
    let dataset = [];
    let header = [];
    let colMap = {};
    let filteredData = [];
    let events = [];
    let selectedEvents = new Set(['__ALL__']);
function isAllSelected() {
  return selectedEvents.has('__ALL__') || selectedEvents.size === 0;
}
function currentAlarmLabel() {
  if (isAllSelected()) return 'All';
  const names = Array.from(selectedEvents);
  return names.length === 1 ? names[0] : `Multiple (${names.length})`;
}

    let searchTerm = '';
    let searchedEvents = [];
    let deviceFilterTerm = '';  // نص فلترة التوربينة (Device/WTG)


    // متغيرات عالمية للاحتفاظ بنطاق التاريخ/الوقت الحاليين
    // يُستخدمان لحساب الإحصاءات بغض النظر عن فلاتر الفئة في جداول الإنذارات المفردة.
    let globalStartFilter = null;
    let globalEndFilter = null;

    // عناصر DOM
    const fileInput = document.getElementById('file-input');
    const messageDiv = document.getElementById('message');
    const filtersDiv = document.getElementById('filters');
    const categoryFiltersDiv = document.getElementById('category-filters');
    const eventListDiv = document.getElementById('event-list');
    const eventSearchInput = document.getElementById('event-search');
    const tableContainer = document.getElementById('table-container');
    const selectedEventTitle = document.getElementById('selected-event-title');
    const exportBtn = document.getElementById('export-btn');
    const exportExcelBtn = document.getElementById('export-excel-btn');
    const exportPdfBtn = document.getElementById('export-pdf-btn');
    const analysisSection = document.getElementById('analysis-section');
    const analysisChartCanvas = document.getElementById('analysis-chart');
const metricAlarm = document.getElementById('metric-alarm');
const metricCount = document.getElementById('metric-count');
const metricDuration = document.getElementById('metric-duration');

    const analysisTableContainer = document.getElementById('analysis-table-container');
    const analysisImgBtn = document.getElementById('analysis-img-btn');
    const analysisPdfBtn = document.getElementById('analysis-pdf-btn');
    let analysisChart = null;
    // تخزين أعداد الإنذارات والمدة لكل عنصر في التحليل لرسمها على الأعمدة
    let analysisCounts = [];
    let analysisDurationsFormatted = [];
// === Sorting state for table ===
let currentSort = { key: null, dir: 'desc' }; // key in ['count','duration'], dir in ['asc','desc']

// Helper: toggle sort
function toggleSort(key) {
  if (currentSort.key === key) {
    currentSort.dir = (currentSort.dir === 'asc') ? 'desc' : 'asc';
  } else {
    currentSort.key = key;
    currentSort.dir = 'desc'; // default to largest -> smallest
  }
  updateTable();
}

// Helper: compare with direction
function compareBy(a, b, key) {
  const sign = (currentSort.dir === 'asc') ? 1 : -1;
  let va = a[key], vb = b[key];
  // Normalize types per column
  if (key === 'count' || key === 'duration') {
    va = Number(va) || 0; vb = Number(vb) || 0;
  } else if (key === 'date') {
    function norm(d) {
      if (!d) return 0;
      if (Array.isArray(d)) {
        const t0 = (d[0] instanceof Date) ? d[0].getTime() : 0;
        const t1 = (d[1] instanceof Date) ? d[1].getTime() : 0;
        return Math.min(t0 || 0, t1 || 0);
      }
      return (d instanceof Date) ? d.getTime() : 0;
    }
    va = norm(va); vb = norm(vb);
  } else {
    va = (va ?? '').toString().toLowerCase();
    vb = (vb ?? '').toString().toLowerCase();
  }
  if (va < vb) return -1 * sign;
  if (va > vb) return 1 * sign;
  return 0;
}


    // تاريخ وزمن التصفية
    const startDateInput = document.getElementById('start-date');
    const endDateInput = document.getElementById('end-date');
    const startTimeInput = document.getElementById('start-time');
    const endTimeInput = document.getElementById('end-time');

    const todayBtn = document.getElementById('today-btn');
    const yesterdayBtn = document.getElementById('yesterday-btn');
    const last24Btn = document.getElementById('last24-btn');
    const clearFilterBtn = document.getElementById('clear-filter-btn');

    // مدخل تصفية التوربينة
    const deviceFilterInput = document.getElementById('device-filter');
    const clearDeviceFilterBtn = document.getElementById('clear-device-filter-btn');


// أحداث إدخال لمسح وتطبيق فلتر التوربينة
if (clearDeviceFilterBtn) {
  clearDeviceFilterBtn.addEventListener('click', () => {
    if (deviceFilterInput) deviceFilterInput.value = '';
    deviceFilterTerm = '';
    updateFilteredData();
  });
}
if (deviceFilterInput) {
  deviceFilterInput.addEventListener('input', () => {
    deviceFilterTerm = (deviceFilterInput.value || '').trim().toLowerCase();
    updateFilteredData();
  });
}

    // إظهار رسالة خطأ
    function showMessage(msg) {
      messageDiv.textContent = msg;
      messageDiv.style.display = 'block';
    }
    function hideMessage() {
      messageDiv.style.display = 'none';
    }

    // كشف الأعمدة بالاعتماد على الأسماء المحتملة
    function detectColumns() {
      const lowerHeader = header.map(h => h.trim().toLowerCase());
      function findCol(possibles) {
        for (let name of possibles) {
          const idx = lowerHeader.indexOf(name.toLowerCase());
          if (idx !== -1) return header[idx];
        }
        return null;
      }
      // مرادفات بالعربية والإنجليزية
      colMap.device = findCol(['device','wtg','turbine','التربينة','التربينات','التركيبة','(device/wtg)','اسم التوربينة']);
      colMap.event = findCol(['event','event name','alarm','alarm name','اسم الإنذار','event/subevent/category','subevent','subevent / categorization']);
      colMap.category = findCol(['category','الفئة','categorization','توصيف','category/event']);
      colMap.duration = findCol(['duration','مدة','duration (hh:mm:ss)','time','المدة']);
      colMap.start = findCol(['start date','start','start time','بداية الحدث','تاريخ البداية']);
      colMap.end = findCol(['end date','end','end time','نهاية الحدث','تاريخ النهاية']);
      // كشف العمود الفرعي (subevent) إن وجد، لعرض اسم الإنذار عند عدم وجود اسم في العمود الأساسي
      colMap.subevent = findCol(['subevent','subevent/categorization','subevent / categorization','categorization description','categorisation description','subevent categorization']);
      // احتياطي: لو لم يتم العثور على event، استخدم subevent إذا كان متاحًا
      if (!colMap.event) {
        colMap.event = findCol(['subevent','subevent / categorization']);
      }
    }

    // تحليل السطر الواحد مع مراعاة علامات الاقتباس
    function splitCSVLine(line, delim) {
      const result = [];
      let current = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (char === '"') {
          if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === delim && !inQuotes) {
          result.push(current);
          current = '';
        } else {
          current += char;
        }
      }
      result.push(current);
      return result;
    }

    // تحليل نص CSV كامل وإرجاع كائن {header,data}
    function parseCSV(text) {
      const lines = text.split(/\r\n|\n|\r/);
      if (!lines.length) return { header: [], data: [] };
      // اكتشاف الفاصل: جرب الفواصل الشائعة واختَر الذي يعطي أكبر عدد من الحقول في الصف الأول
      const candidateDelims = [',',';','\t','|'];
      let bestDelim = ',';
      let maxFields = 0;
      for (const d of candidateDelims) {
        const fields = splitCSVLine(lines[0], d);
        if (fields.length > maxFields) {
          maxFields = fields.length;
          bestDelim = d;
        }
      }
      const delim = bestDelim;
      // تحليل الصفوف مع مراعاة الأسطر داخل الاقتباسات
      const rows = [];
      let currentLine = '';
      let inQuotes = false;
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        currentLine += (currentLine ? '\n' : '') + line;
        // عدّ علامات الاقتباس لمعرفة إذا ما زلنا داخل حقل مقتبس
        let quoteCount = 0;
        for (let j = 0; j < line.length; j++) {
          if (line[j] === '"') quoteCount++;
        }
        if (quoteCount % 2 === 1) {
          // عدد فردي من الاقتباسات في هذا السطر – نواصل على السطر التالي
          continue;
        }
        const record = splitCSVLine(currentLine, delim);
        rows.push(record);
        currentLine = '';
      }
      const headerRow = rows.shift() || [];
      const data = [];
      for (const row of rows) {
        if (row.length === 0 || row.every(cell => cell.trim() === '')) continue;
        const obj = {};
        for (let j = 0; j < headerRow.length; j++) {
          obj[headerRow[j].trim()] = row[j] !== undefined ? row[j].trim() : '';
        }
        data.push(obj);
      }
      return { header: headerRow, data };
    }

    // تحليل مدة على شكل HH:MM:SS أو MM:SS أو ثواني
    function parseDuration(str) {
      if (!str) return 0;
      // أزل الفواصل المنقوطة والفواصل البيضاء
      str = String(str).trim().replace(/;+$/, '');
      if (!str) return 0;
      const parts = str.split(':');
      let seconds = 0;
      if (parts.length === 3) {
        seconds += parseFloat(parts[0]) * 3600;
        seconds += parseFloat(parts[1]) * 60;
        seconds += parseFloat(parts[2].replace(',', '.'));
      } else if (parts.length === 2) {
        seconds += parseFloat(parts[0]) * 60;
        seconds += parseFloat(parts[1].replace(',', '.'));
      } else {
        seconds += parseFloat(str.replace(',', '.'));
      }
      return isNaN(seconds) ? 0 : seconds;
    }

    function formatDuration(seconds) {
      if (seconds <= 0 || isNaN(seconds)) return '00:00';
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = seconds % 60;
      const hh = h > 0 ? String(h).padStart(2, '0') + ':' : '';
      const mm = String(m).padStart(2, '0');
      const ss = s < 10 ? '0' + s.toFixed(0) : s.toFixed(0);
      return hh + mm + ':' + ss;
    }

    // تنسيق التاريخ على شكل YYYY-MM-DD لعرضه في الجدول
    function formatDateShort(date) {
      if (!date || !(date instanceof Date) || isNaN(date.getTime())) return '';
      const yyyy = date.getFullYear();
      const mm = String(date.getMonth() + 1).padStart(2, '0');
      const dd = String(date.getDate()).padStart(2, '0');
      return yyyy + '-' + mm + '-' + dd;
    }

    // قراءة التاريخ والوقت من النصوص
    function parseDateTime(dateStr, timeStr) {
      if (!dateStr) return null;
      let dtStr = dateStr;
      if (timeStr) dtStr += 'T' + timeStr;
      // استخدم Date مباشرة مع التعامل مع الفاصل /
      return new Date(dtStr);
    }
    function parseRowDate(row) {
      const s = row[colMap.start] || '';
      const e = row[colMap.end] || '';
      // جرب تحويل السلسلة مباشرة
      let startDate = null;
      let endDate = null;
      if (s) {
        // استبدل الفراغ بفاصل T إذا كان هناك وقت
        const iso = s.replace(/\//g, '-').replace(' ', 'T');
        startDate = new Date(iso);
      }
      if (e) {
        const iso2 = e.replace(/\//g, '-').replace(' ', 'T');
        endDate = new Date(iso2);
      }
      return { startDate, endDate };
    }

// احسب تقاطع (Overlap) فترة صف واحد مع مجال الفلترة الزمني وأعده بالثواني
function overlapSeconds(startDate, endDate, startFilter, endFilter) {
  if (!(startDate instanceof Date) || !(endDate instanceof Date)) return 0;
  if (isNaN(startDate) || isNaN(endDate)) return 0;
  let s = startDate, e = endDate;
  if (startFilter && e < startFilter) return 0;
  if (endFilter && s > endFilter) return 0;
  if (startFilter && s < startFilter) s = startFilter;
  if (endFilter && e > endFilter) e = endFilter;
  const sec = (e.getTime() - s.getTime()) / 1000;
  return sec > 0 ? sec : 0;
}

// أرجِع التاريخين بعد القصّ داخل مجال الفلترة (إن كان هناك تداخل)، وإلا (null,null)
function clippedDates(startDate, endDate, startFilter, endFilter) {
  if (!(startDate instanceof Date) || !(endDate instanceof Date)) return { cs: null, ce: null };
  if (isNaN(startDate) || isNaN(endDate)) return { cs: null, ce: null };
  let s = startDate, e = endDate;
  if (startFilter && e < startFilter) return { cs: null, ce: null };
  if (endFilter && s > endFilter) return { cs: null, ce: null };
  if (startFilter && s < startFilter) s = startFilter;
  if (endFilter && e > endFilter) e = endFilter;
  if (e <= s) return { cs: null, ce: null };
  return { cs: s, ce: e };
}


    // إنشاء قائمة الفئات
    function buildCategoryFilters() {
      categoryFiltersDiv.innerHTML = '';
      // احسب تكرار الفئات المصنفة (Alarm, State, Warning, Other)
      const counts = {};
      filteredData.forEach(row => {
        let rawCat = row[colMap.category] || '';
        let trimmedCat = rawCat ? String(rawCat).trim() : '';
        const hasSub = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
        let key;
        if (hasSub) {
          key = '__OTHER__';
        } else if (!trimmedCat || trimmedCat.toLowerCase() === 'unknown' || trimmedCat === 'غير معروف' || trimmedCat === 'بدون فئة') {
          key = '__OTHER__';
        } else {
          const lc = trimmedCat.toLowerCase();
          if (lc.includes('alarm') || trimmedCat === 'إنذار') {
            key = 'Alarm';
          } else if (lc.includes('state') || trimmedCat === 'حالة') {
            key = 'State';
          } else if (lc.includes('warning') || trimmedCat === 'تحذير') {
            key = 'Warning';
          } else {
            key = '__OTHER__';
          }
        }
        counts[key] = (counts[key] || 0) + 1;
      });
      // أنشئ مربعات الاختيار للفئات المعروفة إذا كانت موجودة في البيانات
      ['Alarm','State','Warning'].forEach(cat => {
        if (counts[cat]) {
          const id = 'cat-' + cat.toLowerCase();
          const wrapper = document.createElement('div');
          wrapper.className = 'category-item';
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = id;
          checkbox.value = cat;
          checkbox.checked = true;
          checkbox.addEventListener('change', updateFilteredData);
          const label = document.createElement('label');
          label.htmlFor = id;
          label.textContent = cat;
          wrapper.appendChild(checkbox);
          wrapper.appendChild(label);
          categoryFiltersDiv.appendChild(wrapper);
        }
      });
      // أنشئ خيار "Other" إذا كان هناك عناصر غير مصنفة
      if (counts['__OTHER__']) {
        const otherWrapper = document.createElement('div');
        otherWrapper.className = 'category-item';
        const otherCheckbox = document.createElement('input');
        otherCheckbox.type = 'checkbox';
        otherCheckbox.id = 'cat-other';
        otherCheckbox.value = '__OTHER__';
        otherCheckbox.checked = true;
        otherCheckbox.addEventListener('change', updateFilteredData);
        const otherLabel = document.createElement('label');
        otherLabel.htmlFor = 'cat-other';
        otherLabel.textContent = 'Other';
        otherWrapper.appendChild(otherCheckbox);
        otherWrapper.appendChild(otherLabel);
        categoryFiltersDiv.appendChild(otherWrapper);
      }
    }

    // إنشاء قائمة الإنذارات
    function buildEventList(list) {
  const arr = list || events;
  eventListDiv.innerHTML = '';

  if (arr.length > 0) {
    const allBtn = document.createElement('div');
    allBtn.className = 'event-item' + (isAllSelected() ? ' selected' : '');
    allBtn.textContent = 'ALL';
    allBtn.title = 'ALL';
    allBtn.addEventListener('click', () => {
      selectedEvents = new Set(['__ALL__']);
      if (eventSearchInput) eventSearchInput.value = '';
      searchTerm = '';
      filterEventList();
      updateEventSelection();
      updateTable();
      updateAnalysis();
    });
    eventListDiv.appendChild(allBtn);
  }

  arr.forEach(ev => {
    const btn = document.createElement('div');
    btn.className = 'event-item' + (selectedEvents.has(ev) ? ' selected' : '');
    btn.textContent = ev;
    btn.title = ev;
    btn.addEventListener('click', () => {
      if (selectedEvents.has('__ALL__')) selectedEvents.delete('__ALL__');
      if (selectedEvents.has(ev)) {
        selectedEvents.delete(ev);
      } else {
        selectedEvents.add(ev);
      }
      if (selectedEvents.size === 0) selectedEvents.add('__ALL__');
      updateEventSelection();
      updateTable();
      updateAnalysis();
    });
    eventListDiv.appendChild(btn);
  });
}

    // تحديث تحديد الإنذار في القائمة
    function updateEventSelection() {
  const items = eventListDiv.querySelectorAll('.event-item');
  items.forEach(item => {
    const name = item.textContent;
    const isSel = (name === 'ALL' && isAllSelected()) || selectedEvents.has(name);
    item.classList.toggle('selected', isSel);
  });
}

    // تصفية قائمة الإنذارات بناءً على مصطلح البحث
    function filterEventList() {
  if (searchTerm) {
    searchedEvents = events.filter(ev => ev.toLowerCase().includes(searchTerm));
  } else {
    searchedEvents = events.slice();
  }
  const kept = new Set();
  selectedEvents.forEach(n => {
    if (n === '__ALL__' || events.includes(n)) kept.add(n);
  });
  selectedEvents = kept.size ? kept : new Set(['__ALL__']);
  buildEventList(searchedEvents);
  updateTable();
}

    // حدث البحث
    eventSearchInput.addEventListener('input', () => {
      searchTerm = eventSearchInput.value.trim().toLowerCase();
      filterEventList();
    });

    // تحديث البيانات المفلترة وفق الفلاتر
    function updateFilteredData() {
      if (!dataset.length) return;
      hideMessage();
      // تصفية حسب الفئة
      const checkedCats = Array.from(categoryFiltersDiv.querySelectorAll('input[type="checkbox"]'))
        .filter(cb => cb.checked)
        .map(cb => cb.value);
      // نطاق زمني
      const sd = startDateInput.value;
      const ed = endDateInput.value;
      const st = startTimeInput.value;
      const et = endTimeInput.value;
      let startFilter = null;
      let endFilter = null;
      if (sd) {
        startFilter = parseDateTime(sd, st || '00:00');
      }
      if (ed) {
        endFilter = parseDateTime(ed, et || '23:59');
      }
      // خزّن نطاق التاريخ/الوقت الحاليين للاستخدام في حساب الإنذارات الفردية
      globalStartFilter = startFilter;
      globalEndFilter = endFilter;
      filteredData = dataset.filter(row => {
        // Category filtering: classify each row's category into Alarm, State, Warning, or Other
        let rawCat = row[colMap.category] || '';
        let trimmedCat = rawCat ? String(rawCat).trim() : '';
        // Check if a subevent/categorization exists; if yes, treat as 'Other'
        const hasSub = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
        let catKey;
        if (hasSub) {
          catKey = '__OTHER__';
        } else if (!trimmedCat || trimmedCat.toLowerCase() === 'unknown' || trimmedCat === 'غير معروف' || trimmedCat === 'بدون فئة') {
          catKey = '__OTHER__';
        } else {
          const lc = trimmedCat.toLowerCase();
          // Determine known categories; default to Other for anything else
          if (lc.includes('alarm') || trimmedCat === 'إنذار') {
            catKey = 'Alarm';
          } else if (lc.includes('state') || trimmedCat === 'حالة') {
            catKey = 'State';
          } else if (lc.includes('warning') || trimmedCat === 'تحذير') {
            catKey = 'Warning';
          } else {
            catKey = '__OTHER__';
          }
        }
        // Apply category filter: include if catKey is checked
        if (checkedCats.length && !checkedCats.includes(catKey)) return false;
        // Time range filter
        if (startFilter || endFilter) {
          const { startDate, endDate } = parseRowDate(row);
          if (startFilter && (!endDate || endDate < startFilter)) return false;
          if (endFilter && (!startDate || startDate > endFilter)) return false;
        }
        
// Device/Turbine filter
if (deviceFilterTerm) {
  const rawDev = row[colMap.device] || '';
  const devStr = String(rawDev).trim().toLowerCase();
  // مطابقة مرنة: إما احتواء مباشر، أو مطابقة على الأرقام فقط (WTG-05 ~ 5)
  const devDigits = devStr.replace(/\D/g, '');
  const filterDigits = deviceFilterTerm.replace(/\D/g, '');
  const containsText = devStr.includes(deviceFilterTerm);
  const containsDigits = filterDigits ? devDigits.includes(filterDigits) : true;
  if (!(containsText || containsDigits)) return false;
}
return true;
      });
      // جلب الإنذارات الفريدة مع تجاهل القيم غير المعروفة
      const evSet = new Set();
      filteredData.forEach(row => {
        // استخدم اسم الإنذار الأساسي أو الفرعي إذا كان الأساسي فارغًا
        let rawName = '';
        if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
          rawName = row[colMap.event];
        } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
          rawName = row[colMap.subevent];
        }
        const name = (rawName || '').trim();
        // استبعد الأسماء الفارغة أو "غير معروف" أو "unknown" (بعد إزالة الفراغات)
        if (!name || name === 'غير معروف' || name.toLowerCase() === 'unknown') {
          return;
        }
        evSet.add(name);
      });
      events = Array.from(evSet).sort((a,b) => a.localeCompare(b, 'ar'));
const intersection = new Set();
selectedEvents.forEach(n => { if (n === '__ALL__' || evSet.has(n)) intersection.add(n); });
selectedEvents = intersection.size ? intersection : new Set(['__ALL__']);
 // sort alphabetically
      // إذا لم يكن الإنذار المختار ضمن القائمة الحالية اختر أول عنصر
      // إلا إذا كان الاختيار هو كل الأحداث (__ALL__)،
      // ففي هذه الحالة نحتفظ به حتى يتمكن المستخدم من رؤية جميع الإنذارات.
      if (!isAllSelected()) {
        if (!Array.from(selectedEvents)[0] || !evSet.has(Array.from(selectedEvents)[0])) {
          Array.from(selectedEvents)[0] = events.length ? events[0] : null;
        }
      }
      // بعد تحديث قائمة الإنذارات والأحداث المفلترة، طبّق البحث الحالي لتصفية القائمة إن وجد
      filterEventList();
      // حدّث التحليل لأعلى التوربينات
      updateAnalysis();
    }

    // حساب وتجهيز البيانات الخاصة بإنذار واحد وعرضها في الجدول
    function updateTable() {
  tableContainer.innerHTML = '';
  /* reveal export buttons once a table is present */
  try { exportBtn.style.display=''; exportExcelBtn.style.display=''; exportPdfBtn.style.display=''; } catch(_) {}

  exportBtn.style.display = 'none';
  exportExcelBtn.style.display = 'none';
  /* keep hidden until data is ready */

  if (!events.length) {
    selectedEventTitle.textContent = '';
    return;
  }
  selectedEventTitle.textContent = 'Alarm: ' + currentAlarmLabel() + (deviceFilterTerm ? ('  |  Turbine: ' + (deviceFilterInput ? deviceFilterInput.value : deviceFilterTerm)) : '');

  const rows = [];

  function rowTypeOf(row) {
    const hasSub = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
    if (hasSub) return 'Other';
    const cat = (row[colMap.category] || '').toString().toLowerCase();
    if (cat.includes('alarm') || row[colMap.category] === 'إنذار') return 'Alarm';
    if (cat.includes('state') || row[colMap.category] === 'حالة') return 'State';
    if (cat.includes('warning') || row[colMap.category] === 'تحذير') return 'Warning';
    return 'Other';
  }
  function getEventName(row) {
    if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') return row[colMap.event].trim();
    if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') return row[colMap.subevent].trim();
    return '';
  }
  function getDur(row) {
    // لو يوجد Start/End قصّ المدة داخل مجال الفلترة
    if (colMap.start && colMap.end) {
      const { startDate, endDate } = parseRowDate(row);
      if (startDate && endDate) {
        if (globalStartFilter || globalEndFilter) {
          return overlapSeconds(startDate, endDate, globalStartFilter, globalEndFilter);
        }
        return (endDate.getTime() - startDate.getTime()) / 1000;
      }
    }
    // وإلا لو يوجد Duration فقط ولا يمكن القصّ، استخدمه كما هو
    if (colMap.duration && row[colMap.duration]) return parseDuration(row[colMap.duration]);
    return 0;
  }

  const multiMode = !isAllSelected() && selectedEvents.size > 1;

  if (isAllSelected() || multiMode) {
    let useData = filteredData;
    (function decideSource() {
      const cbs = Array.from(categoryFiltersDiv.querySelectorAll('input[type="checkbox"]'));
      const allCats = cbs.length > 0 && cbs.every(cb => cb.checked);
      if (allCats && !globalStartFilter && !globalEndFilter && !deviceFilterTerm) useData = dataset;
    })();

    const group = {};
    useData.forEach(row => {
      const evName = getEventName(row);
      if (!evName) return;
      if (!isAllSelected() && !selectedEvents.has(evName)) return;

      const rawDev = row[colMap.device];
      if (!rawDev) return;
      const dev = String(rawDev).trim();
      if (!dev || dev.toLowerCase() === 'unknown' || dev === 'غير معروف') return;

      const key = evName + '___' + dev;
      if (!group[key]) group[key] = { event: evName, device: dev, count: 0, duration: 0, earliest: null, latest: null, typeCounts: {} };
      const g = group[key];
      g.count++;
      g.duration += getDur(row);

      const t = rowTypeOf(row);
      g.typeCounts[t] = (g.typeCounts[t] || 0) + 1;

      const { startDate, endDate } = parseRowDate(row);
if (startDate && endDate) {
  let cs = startDate, ce = endDate;
  if (globalStartFilter || globalEndFilter) {
    const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
    cs = clip.cs; ce = clip.ce;
  }
  if (cs && ce) {
    if (!g.earliest || cs < g.earliest) g.earliest = cs;
    if (!g.latest || ce > g.latest) g.latest = ce;
  }
}

    });

    Object.values(group).forEach(s => {
      let chosenType = '';
      let maxT = 0;
      for (const t in s.typeCounts) if (s.typeCounts[t] > maxT) { maxT = s.typeCounts[t]; chosenType = t; }
      let dateVal = s.earliest
        ? (s.latest && s.earliest.toDateString() !== s.latest.toDateString() ? [s.earliest, s.latest] : s.earliest)
        : null;
      rows.push({ event: s.event, date: dateVal, type: chosenType, device: s.device, count: s.count, duration: s.duration });
    });

  } else {
    const only = Array.from(selectedEvents)[0];
    const counts = {};
    const earliest = {};
    const latest = {};
    let eventType = '';

    let useDataSel = filteredData;
      (function decideSourceSel(){
        const cbs = Array.from(categoryFiltersDiv.querySelectorAll('input[type="checkbox"]'));
        const allCats = cbs.length > 0 && cbs.every(cb => cb.checked);
        if (allCats && !globalStartFilter && !globalEndFilter && !deviceFilterTerm) useDataSel = dataset;
      })();
      useDataSel.forEach(row => {
      const evName = getEventName(row);
      if (evName !== only) return;

      if (globalStartFilter || globalEndFilter) {
        const { startDate, endDate } = parseRowDate(row);
        if (globalStartFilter && (!endDate || endDate < globalStartFilter)) return;
        if (globalEndFilter && (!startDate || startDate > globalEndFilter)) return;
      }

      // enforce turbine filter when a term is present
      if (deviceFilterTerm) {
        const rawDev = row[colMap.device] || '';
        const devStr = String(rawDev).trim().toLowerCase();
        const devDigits = devStr.replace(/\D/g, '');
        const filterDigits = deviceFilterTerm.replace(/\D/g, '');
        const containsText = devStr.includes(deviceFilterTerm);
        const containsDigits = filterDigits ? devDigits.includes(filterDigits) : true;
        if (!(containsText || containsDigits)) return;
      }

      const rawDev = row[colMap.device];
      if (!rawDev) return;
      const dev = String(rawDev).trim();
      if (!dev || dev.toLowerCase() === 'unknown' || dev === 'غير معروف') return;

      if (!counts[dev]) counts[dev] = { count: 0, duration: 0 };
      counts[dev].count++;
      counts[dev].duration += getDur(row);

      const t = rowTypeOf(row);
      if (!eventType) eventType = t;

      const { startDate, endDate } = parseRowDate(row);
if (startDate && endDate) {
  let cs = startDate, ce = endDate;
  if (globalStartFilter || globalEndFilter) {
    const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
    cs = clip.cs; ce = clip.ce;
  }
  if (cs && ce) {
    if (!earliest[dev] || cs < earliest[dev]) earliest[dev] = cs;
    if (!latest[dev] || ce > latest[dev]) latest[dev] = ce;
  }
}

    });

    Object.keys(counts).forEach(dev => {
      const e = earliest[dev] || null;
      const l = latest[dev] || null;
      const dateVal = e ? (l && e.toDateString() !== l.toDateString() ? [e, l] : e) : null;
      rows.push({ event: only, date: dateVal, type: eventType, device: dev, count: counts[dev].count, duration: counts[dev].duration });
    });
  }

  if (currentSort.key) {
    rows.sort((a,b) => compareBy(a,b,currentSort.key));
} else {
    rows.sort((a,b) => (b.count - a.count) || (b.duration - a.duration));
}

  if (!rows.length) {
    const info = document.createElement('p');
    info.textContent = 'No records match the filters.';
    tableContainer.appendChild(info);
    return;
  }

  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const trh = document.createElement('tr');
  
['Alarm Name','Type','Date','Turbine','Occurrences','Total Duration'].forEach((text, idx) => {
    const th = document.createElement('th'); 
    th.textContent = text; 
    // Sortable headers: Date (idx 2), Turbine (idx 3), Occurrences (idx 4), Total Duration (idx 5)
    const keysByIdx = {2:'date', 3:'device', 4:'count', 5:'duration'};
    if (keysByIdx[idx]) {
      th.style.cursor = 'pointer';
      th.classList.add('sortable-th');
      const arrow = document.createElement('span');
      arrow.style.marginLeft = '6px';
      const key = keysByIdx[idx];
      if (currentSort.key === key) {
        arrow.textContent = currentSort.dir === 'asc' ? '▲' : '▼';
        arrow.style.opacity = '1';
      } else {
        arrow.textContent = '▼';
        arrow.style.opacity = '0.35';
      }
      th.appendChild(arrow);
      th.addEventListener('click', () => { toggleSort(key); });
    }
    trh.appendChild(th);
  });thead.appendChild(trh); table.appendChild(thead);

  const tbody = document.createElement('tbody');
  rows.forEach(r => {
    const tr = document.createElement('tr');
    const tdEvent = document.createElement('td'); tdEvent.textContent = r.event;
    const tdType  = document.createElement('td'); tdType.textContent  = r.type || '';
    const tdDate  = document.createElement('td');
    if (Array.isArray(r.date)) tdDate.textContent = formatDateShort(r.date[0]) + ' - ' + formatDateShort(r.date[1]);
    else tdDate.textContent = r.date ? formatDateShort(r.date) : '';
    const tdDev   = document.createElement('td'); tdDev.textContent   = r.device;
    const tdCnt   = document.createElement('td'); tdCnt.textContent   = r.count;
    const tdDur   = document.createElement('td'); tdDur.textContent   = formatDuration(r.duration);
    tr.append(tdEvent, tdType, tdDate, tdDev, tdCnt, tdDur);
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  tableContainer.appendChild(table);
      try{ window.__ensureAllExportButtons && window.__ensureAllExportButtons(); window.__bindDomExportsAll && window.__bindDomExportsAll(); }catch(_){}
      try{ window.__bindDomTableExports && window.__bindDomTableExports(); }catch(_){}
      try{ window.__ensurePdfButton && window.__ensurePdfButton(); window.__bindPdfExport && window.__bindPdfExport(); }catch(_){}
      try{ window.__ensurePdfButton && window.__ensurePdfButton(); }catch(_){}

  exportBtn.style.display = 'inline-block';
  exportExcelBtn.style.display = 'inline-block';
  exportPdfBtn.style.display = 'inline-block';
}

    // تصدير الجدول الحالي إلى ملف CSV
    function exportCurrentTable() {
      if (!Array.from(selectedEvents)[0]) return;
      const lines = [];
      // CSV header includes event type and date columns
      lines.push(['Event','Type','Date','Device','Count','Duration'].join(','));
      const counts = {};
      const typeCountsPerDevice = {};
      const earliestDates = {};
      const latestDates = {};
      const eventCountsPerDevice = {};
      // اختر مصدر البيانات حسب الاختيار: إذا كان "الكل" استخدم البيانات المفلترة، وإذا كان إنذارًا محددًا استخدم مجموعة البيانات كاملة
      const dataForExport = (isAllSelected() || deviceFilterTerm) ? filteredData : dataset;
      dataForExport.forEach(row => {
        // استخدم اسم الإنذار الأساسي أو الفرعي
        let evName = '';
        if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
          evName = row[colMap.event];
        } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
          evName = row[colMap.subevent];
        }
        // عند اختيار إنذار محدد، تجاهل الصفوف التي لا تتطابق معه
        if (!isAllSelected() && evName !== Array.from(selectedEvents)[0]) return;
        // عند اختيار إنذار محدد، طبّق فلتر الوقت المخزن
        if (!isAllSelected()) {
          if (globalStartFilter || globalEndFilter) {
            const { startDate, endDate } = parseRowDate(row);
            if (globalStartFilter && (!endDate || endDate < globalStartFilter)) return;
            if (globalEndFilter && (!startDate || startDate > globalEndFilter)) return;
          }
        }
        const rawDev = row[colMap.device];
        if (!rawDev) return;
        const trimmedDev = String(rawDev).trim();
        if (!trimmedDev || trimmedDev === 'غير معروف' || trimmedDev.toLowerCase() === 'unknown') return;
        const dev = trimmedDev;
        if (!counts[dev]) counts[dev] = { count: 0, duration: 0 };
        counts[dev].count++;
        if (colMap.start && colMap.end) {
          const { startDate, endDate } = parseRowDate(row);
          if (startDate && endDate) {
            const dur = (globalStartFilter || globalEndFilter) ? overlapSeconds(startDate, endDate, globalStartFilter, globalEndFilter) : (endDate.getTime() - startDate.getTime()) / 1000;
            counts[dev].duration += dur;
          }
        } else if (colMap.duration && row[colMap.duration]) {
          // لا يمكن قصّها لعدم وجود تواريخ واضحة
          counts[dev].duration += parseDuration(row[colMap.duration]);
        }
        // تحديد نوع الصف
        let rowType = '';
        const hasSubEvent = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
        if (hasSubEvent) {
          rowType = 'Other';
        } else {
          let cat = row[colMap.category] || '';
          let lcCat = cat ? cat.toString().toLowerCase() : '';
          if (lcCat.includes('alarm') || cat === 'إنذار') {
            rowType = 'Alarm';
          } else if (lcCat.includes('state') || cat === 'حالة') {
            rowType = 'State';
          } else if (lcCat.includes('warning') || cat === 'تحذير') {
            rowType = 'Warning';
          } else {
            rowType = 'Other';
          }
        }
        if (rowType) {
          if (!typeCountsPerDevice[dev]) typeCountsPerDevice[dev] = {};
          typeCountsPerDevice[dev][rowType] = (typeCountsPerDevice[dev][rowType] || 0) + 1;
        }
        // تتبع أقدم وأحدث تواريخ بعد القصّ داخل مجال الفلترة
        const { startDate, endDate } = parseRowDate(row);
        if (startDate && endDate) {
          let cs = startDate, ce = endDate;
          if (globalStartFilter || globalEndFilter) {
            const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
            cs = clip.cs; ce = clip.ce;
          }
          if (cs && ce) {
            if (!earliestDates[dev] || cs < earliestDates[dev]) {
              earliestDates[dev] = cs;
            }
            if (!latestDates[dev] || ce > latestDates[dev]) {
              latestDates[dev] = ce;
            }
          }
        }

        // عدّ كل إنذار لكل توربينة عند التصدير لـ "الكل"
        if (isAllSelected()) {
          let evName2 = '';
          if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
            evName2 = row[colMap.event];
          } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
            evName2 = row[colMap.subevent];
          }
          if (!eventCountsPerDevice[dev]) eventCountsPerDevice[dev] = {};
          eventCountsPerDevice[dev][evName2] = (eventCountsPerDevice[dev][evName2] || 0) + 1;
        }
      });
      // Determine eventType for specific selection
      let eventType = '';
      if (!isAllSelected()) {
        const dataForType = dataset;
        for (const row of dataForType) {
          // Apply time filter if present
          if (globalStartFilter || globalEndFilter) {
            const { startDate, endDate } = parseRowDate(row);
            if (globalStartFilter && (!endDate || endDate < globalStartFilter)) continue;
            if (globalEndFilter && (!startDate || startDate > globalEndFilter)) continue;
          }
          let evName = '';
          if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
            evName = row[colMap.event];
          } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
            evName = row[colMap.subevent];
          }
          if (evName === Array.from(selectedEvents)[0]) {
            const hasSubEvt = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
            if (hasSubEvt) {
              eventType = 'Other';
            } else {
              let cat = row[colMap.category] || '';
              let lcCat = cat ? cat.toString().toLowerCase() : '';
              if (lcCat.includes('alarm') || cat === 'إنذار') {
                eventType = 'Alarm';
              } else if (lcCat.includes('state') || cat === 'حالة') {
                eventType = 'State';
              } else if (lcCat.includes('warning') || cat === 'تحذير') {
                eventType = 'Warning';
              } else {
                eventType = 'Other';
              }
            }
            break;
          }
        }
      }
      // Build lines: إذا كان الاختيار "الكل"، تجميع حسب اسم الإنذار، وإلا تجميع حسب التوربينة
      if (isAllSelected()) {
        // تجميع حسب الإنذار والتوربينة
        const groupStats = {};
        // حدد مجموعة البيانات للتصدير: إذا كانت كل الفئات محددة ولا يوجد فلتر زمني، استخدم dataset
        let useData;
        (function determineExportData() {
          const catCheckboxes = Array.from(categoryFiltersDiv.querySelectorAll('input[type="checkbox"]'));
          const allCatsChecked = catCheckboxes.length > 0 && catCheckboxes.every(cb => cb.checked);
          if (allCatsChecked && !globalStartFilter && !globalEndFilter) {
            useData = dataset;
          } else {
            useData = filteredData;
          }
        })();
        useData.forEach(row => {
          // event name
          let evName = '';
          if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
            evName = row[colMap.event];
          } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
            evName = row[colMap.subevent];
          }
          if (!evName) return;
          const name = evName.trim();
          if (!name || name.toLowerCase() === 'unknown' || name === 'غير معروف') return;
          // device name
          const rawDev = row[colMap.device];
          if (!rawDev) return;
          const trimmedDev = String(rawDev).trim();
          if (!trimmedDev || trimmedDev === 'غير معروف' || trimmedDev.toLowerCase() === 'unknown') return;
          const key = name + '___' + trimmedDev;
          if (!groupStats[key]) {
            groupStats[key] = { event: name, device: trimmedDev, count: 0, duration: 0, earliest: null, latest: null, typeCounts: {} };
          }
          const stat = groupStats[key];
          stat.count++;
          // duration
          if (colMap.duration && row[colMap.duration]) {
            stat.duration += parseDuration(row[colMap.duration]);
          } else if (colMap.start && colMap.end) {
            const { startDate, endDate } = parseRowDate(row);
            if (startDate && endDate) {
              const dur = (globalStartFilter || globalEndFilter) ? overlapSeconds(startDate, endDate, globalStartFilter, globalEndFilter) : (endDate.getTime() - startDate.getTime()) / 1000;
              stat.duration += dur;
            }
          }
          // type classification
          let rowType = '';
          const hasSubEvent = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
          if (hasSubEvent) {
            rowType = 'Other';
          } else {
            let cat = row[colMap.category] || '';
            let lc = cat ? cat.toString().toLowerCase() : '';
            if (lc.includes('alarm') || cat === 'إنذار') {
              rowType = 'Alarm';
            } else if (lc.includes('state') || cat === 'حالة') {
              rowType = 'State';
            } else if (lc.includes('warning') || cat === 'تحذير') {
              rowType = 'Warning';
            } else {
              rowType = 'Other';
            }
          }
          stat.typeCounts[rowType] = (stat.typeCounts[rowType] || 0) + 1;
          // dates
          const { startDate, endDate } = parseRowDate(row);
          if (startDate && endDate) {
            let cs = startDate, ce = endDate;
            if (globalStartFilter || globalEndFilter) {
              const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
              cs = clip.cs; ce = clip.ce;
            }
            if (cs && ce) {
              if (!stat.earliest || cs < stat.earliest) stat.earliest = cs;
              if (!stat.latest || ce > stat.latest) stat.latest = ce;
            }
          }
        });
        Object.keys(groupStats).forEach(k => {
          const s = groupStats[k];
          // choose most frequent type
          let chosenType = '';
          let maxT = 0;
          for (const t in s.typeCounts) {
            if (s.typeCounts[t] > maxT) {
              maxT = s.typeCounts[t];
              chosenType = t;
            }
          }
          let dateVal = '';
          const e = s.earliest;
          const l = s.latest;
          if (e && l && e instanceof Date && l instanceof Date && e.toDateString() !== l.toDateString()) {
            dateVal = formatDateShort(e) + ' - ' + formatDateShort(l);
          } else if (e) {
            dateVal = formatDateShort(e);
          }
          const dur = formatDuration(s.duration);
          lines.push([s.event, chosenType, dateVal, s.device, s.count, dur].join(','));
        });
      } else {
        // تجميع حسب التوربينة لإنذار محدد
        Object.keys(counts).forEach(dev => {
          const obj = counts[dev];
          const dur = formatDuration(obj.duration);
          let type = eventType || '';
          let dateVal = '';
          const e = earliestDates[dev];
          const l = latestDates[dev];
          if (e && l && e instanceof Date && l instanceof Date && e.toDateString() !== l.toDateString()) {
            dateVal = formatDateShort(e) + ' - ' + formatDateShort(l);
          } else if (e) {
            dateVal = formatDateShort(e);
          }
          lines.push([Array.from(selectedEvents)[0], type, dateVal, dev, obj.count, dur].join(','));
        });
      }
      const csvContent = lines.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      const sheetName = (isAllSelected() ? 'All' : (selectedEvents.size === 1 ? Array.from(selectedEvents)[0] : ('Multiple_' + selectedEvents.size))).replace(/[\/:*?"<>|]+/g, '_');
      link.download = 'alarm_' + sheetName + '.csv';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    /*
     * التحليل والتصدير الإضافي
     */

    // تحميل مكتبة jsPDF و html2canvas عند الحاجة
    function loadPDFLib() {
      return new Promise((resolve, reject) => {
        if (window.jspdf && window.html2canvas) {
          resolve();
          return;
        }
        let loaded = 0;
        function done() {
          loaded++;
          if (loaded === 2) resolve();
        }
        function fail() {
          reject();
        }
        const script1 = document.createElement('script');
        script1.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
        script1.onload = done;
        script1.onerror = fail;
        document.head.appendChild(script1);
        const script2 = document.createElement('script');
        script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
        script2.onload = done;
        script2.onerror = fail;
        document.head.appendChild(script2);
      });
    }

    // تحميل Chart.js عند الحاجة
    function loadChartJS() {
      return new Promise((resolve, reject) => {
        if (window.Chart) {
          resolve();
          return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
        script.onload = () => resolve();
        script.onerror = () => reject();
        document.head.appendChild(script);
      });
    }

    // تصدير الجدول الحالي إلى Excel
    function exportCurrentTableExcel() {
      if (!Array.from(selectedEvents)[0]) return;
      loadXLSX().then(() => {
        // Include event type and date columns in the Excel export
        const headerRow = ['Event','Type','Date','Device','Count','Duration'];
        const dataRows = [];
        const counts = {};
        // Determine the type/category of the selected event
        let eventType = '';
        if (!isAllSelected()) {
          // Scan the entire dataset (with time filter) to determine the first matching row's type
          for (const row of dataset) {
            // Apply time filter
            if (globalStartFilter || globalEndFilter) {
              const { startDate, endDate } = parseRowDate(row);
              if (globalStartFilter && (!endDate || endDate < globalStartFilter)) continue;
              if (globalEndFilter && (!startDate || startDate > globalEndFilter)) continue;
            }
            let evName = '';
            if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
              evName = row[colMap.event];
            } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
              evName = row[colMap.subevent];
            }
            if (evName === Array.from(selectedEvents)[0]) {
              if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
                eventType = 'Other';
              } else {
                let catVal = row[colMap.category] || '';
                let lcVal = catVal ? catVal.toString().toLowerCase() : '';
                if (lcVal.includes('alarm') || catVal === 'إنذار') {
                  eventType = 'Alarm';
                } else if (lcVal.includes('state') || catVal === 'حالة') {
                  eventType = 'State';
                } else if (lcVal.includes('warning') || catVal === 'تحذير') {
                  eventType = 'Warning';
                } else {
                  eventType = 'Other';
                }
              }
              break;
            }
          }
        }
        const earliestDates = {};
        const latestDates = {};
        const typeCountsPerDevice = {};
        const eventCountsPerDevice = {};
        // اختر مصدر البيانات: إذا كان "الكل" استخدم البيانات المفلترة، وإلا استخدم مجموعة البيانات كاملة
        const dataForExportExcel = (isAllSelected()) ? filteredData : dataset;
        dataForExportExcel.forEach(row => {
          let evName = '';
          if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
            evName = row[colMap.event];
          } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
            evName = row[colMap.subevent];
          }
          if (!isAllSelected() && evName !== Array.from(selectedEvents)[0]) return;
          // Apply time filter for specific event
          if (!isAllSelected()) {
            if (globalStartFilter || globalEndFilter) {
              const { startDate, endDate } = parseRowDate(row);
              if (globalStartFilter && (!endDate || endDate < globalStartFilter)) return;
              if (globalEndFilter && (!startDate || startDate > globalEndFilter)) return;
            }
          }
          const rawDev = row[colMap.device];
          if (!rawDev) return;
          const trimmedDev = String(rawDev).trim();
          if (!trimmedDev || trimmedDev === 'غير معروف' || trimmedDev.toLowerCase() === 'unknown') return;
          const dev = trimmedDev;
          if (!counts[dev]) counts[dev] = { count: 0, duration: 0 };
          counts[dev].count++;
          if (colMap.duration && row[colMap.duration]) {
            counts[dev].duration += parseDuration(row[colMap.duration]);
          } else if (colMap.start && colMap.end) {
            const { startDate, endDate } = parseRowDate(row);
            if (startDate && endDate) counts[dev].duration += (endDate.getTime() - startDate.getTime()) / 1000;
          }
          // classify this row for type and count event occurrences when exporting all
          let rowType = '';
          const hasSubEvent = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
          if (hasSubEvent) {
            rowType = 'Other';
          } else {
            let catVal = row[colMap.category] || '';
            let lcVal = catVal ? catVal.toString().toLowerCase() : '';
            if (lcVal.includes('alarm') || catVal === 'إنذار') {
              rowType = 'Alarm';
            } else if (lcVal.includes('state') || catVal === 'حالة') {
              rowType = 'State';
            } else if (lcVal.includes('warning') || catVal === 'تحذير') {
              rowType = 'Warning';
            } else {
              rowType = 'Other';
            }
          }
          if (rowType) {
            if (!typeCountsPerDevice[dev]) typeCountsPerDevice[dev] = {};
            typeCountsPerDevice[dev][rowType] = (typeCountsPerDevice[dev][rowType] || 0) + 1;
          }
          // Count events per device when Array.from(selectedEvents)[0] is "All"
          if (isAllSelected()) {
            let evName2 = '';
            if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
              evName2 = row[colMap.event];
            } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
              evName2 = row[colMap.subevent];
            }
            if (!eventCountsPerDevice[dev]) eventCountsPerDevice[dev] = {};
            eventCountsPerDevice[dev][evName2] = (eventCountsPerDevice[dev][evName2] || 0) + 1;
          }
          // track earliest and latest dates
          const { startDate, endDate } = parseRowDate(row);
          if (startDate && endDate) {
  let cs = startDate, ce = endDate;
  if (globalStartFilter || globalEndFilter) {
    const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
    cs = clip.cs; ce = clip.ce;
  }
  if (cs && ce) {
    if (!earliestDates[dev] || cs < earliestDates[dev]) { earliestDates[dev] = cs; }
    if (!latestDates[dev] || ce > latestDates[dev]) { latestDates[dev] = ce; }
  }
}

        });
        if (isAllSelected()) {
          // تجميع حسب الإنذار والتوربينة
          const groupStats = {};
          // حدد مجموعة البيانات للتصدير: استخدم كامل البيانات إذا كانت كل الفئات محددة ولا يوجد فلتر زمني
          let useData;
          (function determineExportData() {
            const catCheckboxes = Array.from(categoryFiltersDiv.querySelectorAll('input[type="checkbox"]'));
            const allCatsChecked = catCheckboxes.length > 0 && catCheckboxes.every(cb => cb.checked);
            if (allCatsChecked && !globalStartFilter && !globalEndFilter) {
              useData = dataset;
            } else {
              useData = filteredData;
            }
          })();
          useData.forEach(row => {
            let evName = '';
            if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
              evName = row[colMap.event];
            } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
              evName = row[colMap.subevent];
            }
            if (!evName) return;
            const name = evName.trim();
            if (!name || name.toLowerCase() === 'unknown' || name === 'غير معروف') return;
            const rawDev = row[colMap.device];
            if (!rawDev) return;
            const trimmedDev = String(rawDev).trim();
            if (!trimmedDev || trimmedDev === 'غير معروف' || trimmedDev.toLowerCase() === 'unknown') return;
            const key = name + '___' + trimmedDev;
            if (!groupStats[key]) {
              groupStats[key] = { event: name, device: trimmedDev, count: 0, duration: 0, earliest: null, latest: null, typeCounts: {} };
            }
            const stat = groupStats[key];
            stat.count++;
            if (colMap.duration && row[colMap.duration]) {
              stat.duration += parseDuration(row[colMap.duration]);
            } else if (colMap.start && colMap.end) {
              const { startDate, endDate } = parseRowDate(row);
              if (startDate && endDate) stat.duration += (endDate.getTime() - startDate.getTime()) / 1000;
            }
            // classify type
            let rowType = '';
            const hasSubEvent = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
            if (hasSubEvent) {
              rowType = 'Other';
            } else {
              let catVal = row[colMap.category] || '';
              let lcVal = catVal ? catVal.toString().toLowerCase() : '';
              if (lcVal.includes('alarm') || catVal === 'إنذار') {
                rowType = 'Alarm';
              } else if (lcVal.includes('state') || catVal === 'حالة') {
                rowType = 'State';
              } else if (lcVal.includes('warning') || catVal === 'تحذير') {
                rowType = 'Warning';
              } else {
                rowType = 'Other';
              }
            }
            stat.typeCounts[rowType] = (stat.typeCounts[rowType] || 0) + 1;
// dates (clipped to filter window)
const { startDate, endDate } = parseRowDate(row);
if (startDate && endDate) {
  let cs = startDate, ce = endDate;
  if (globalStartFilter || globalEndFilter) {
    const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
    cs = clip.cs; ce = clip.ce;
  }
  if (cs && ce) {
    if (!stat.earliest || cs < stat.earliest) stat.earliest = cs;
    if (!stat.latest || ce > stat.latest) stat.latest = ce;
  }
}

          });
          Object.keys(groupStats).forEach(k => {
            const s = groupStats[k];
            let chosenType = '';
            let maxT = 0;
            for (const t in s.typeCounts) {
              if (s.typeCounts[t] > maxT) {
                maxT = s.typeCounts[t];
                chosenType = t;
              }
            }
            let dateVal = '';
            const e = s.earliest;
            const l = s.latest;
            if (e && l && e instanceof Date && l instanceof Date && e.toDateString() != l.toDateString()) {
              dateVal = formatDateShort(e) + ' - ' + formatDateShort(l);
            } else if (e) {
              dateVal = formatDateShort(e);
            }
            dataRows.push([s.event, chosenType, dateVal, s.device, s.count, formatDuration(s.duration)]);
          });
        } else {
          // تجميع حسب التوربينة لإنذار محدد
          Object.keys(counts).forEach(dev => {
            const obj = counts[dev];
            let typeForDev = eventType || '';
            let dateVal = '';
            const e = earliestDates[dev];
            const l = latestDates[dev];
            if (e && l && e instanceof Date && l instanceof Date && e.toDateString() !== l.toDateString()) {
              dateVal = formatDateShort(e) + ' - ' + formatDateShort(l);
            } else if (e) {
              dateVal = formatDateShort(e);
            }
            dataRows.push([Array.from(selectedEvents)[0], typeForDev, dateVal, dev, obj.count, formatDuration(obj.duration)]);
          });
        }
        if (!dataRows.length) return;
        const wsData = [headerRow, ...dataRows];
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        const wb = XLSX.utils.book_new();
        const sheetName = (isAllSelected() ? 'All' : (selectedEvents.size === 1 ? Array.from(selectedEvents)[0] : ('Multiple_' + selectedEvents.size))).replace(/[\/:*?"<>|]+/g, '_');
        XLSX.utils.book_append_sheet(wb, ws, sheetName);
        const fileName = 'alarm_' + sheetName + '.xlsx';
        XLSX.writeFile(wb, fileName);
      }).catch(() => {
        showMessage('Failed to load the Excel export library. Please connect to the internet');
      });
    }

    // تصدير الجدول الحالي إلى PDF
    function exportCurrentTablePDF() {
      if (!Array.from(selectedEvents)[0]) return;
      loadPDFLib().then(() => {
        // قم بتخزين القيم الأصلية للثيم قبل التعديل
        const root = document.documentElement;
        const oldBg = getComputedStyle(root).getPropertyValue('--bg-color');
        const oldSidebar = getComputedStyle(root).getPropertyValue('--sidebar-color');
        const oldAccent = getComputedStyle(root).getPropertyValue('--accent-color');
        const oldText = getComputedStyle(root).getPropertyValue('--text-color');
        const oldHighlight = getComputedStyle(root).getPropertyValue('--highlight-color');
        // غيّر الألوان مؤقتًا لتهيئة تصدير الـPDF بنص أسود وخلفية بيضاء
        root.style.setProperty('--bg-color', '#ffffff');
        root.style.setProperty('--sidebar-color', '#ffffff');
        root.style.setProperty('--accent-color', '#cccccc');
        root.style.setProperty('--highlight-color', '#dddddd');
        root.style.setProperty('--text-color', '#000000');
        // أنشئ عنصرًا مؤقتًا يضم عنوان الإنذار، الجدول، والرسم البياني
        const wrapper = document.createElement('div');
        wrapper.style.backgroundColor = '#ffffff';
        wrapper.style.color = '#000000';
        wrapper.style.padding = '16px';
        wrapper.style.fontSize = '14px';
        wrapper.style.lineHeight = '1.4';
        // أضف عنوان الإنذار
        const title = document.createElement('h2');
        title.style.marginBottom = '12px';
        title.textContent = selectedEventTitle.textContent;
        wrapper.appendChild(title);
        // نسخ الجدول الحالي
        const tableEl = tableContainer.querySelector('table');
        if (tableEl) {
          const tableClone = tableEl.cloneNode(true);
          // استبدل ألوان الخلفية للجدول بالعناصر الفاتحة
          tableClone.querySelectorAll('th').forEach(th => {
            th.style.backgroundColor = '#cccccc';
            th.style.color = '#000000';
          });
          tableClone.querySelectorAll('td').forEach(td => {
            td.style.backgroundColor = '#ffffff';
            td.style.color = '#000000';
          });
          tableClone.style.width = '100%';
          wrapper.appendChild(tableClone);
        }
        // إضافة الرسم البياني (إن وجد) كصورة أسفل الجدول
        if (analysisChart) {
          const chartImg = new Image();
          // استخدام toDataURL للحصول على صورة للرسم البياني الحالي
          chartImg.src = analysisChartCanvas.toDataURL('image/png');
          chartImg.style.display = 'block';
          chartImg.style.marginTop = '16px';
          chartImg.style.maxWidth = '100%';
          wrapper.appendChild(chartImg);
        }
        document.body.appendChild(wrapper);
        // استخدام html2canvas لالتقاط العنصر كاملاً بدقة أعلى
        window.html2canvas(wrapper, { scale: 2 }).then(canvas => {
          // إعادة القيم القديمة لخصائص الثيم
          root.style.setProperty('--bg-color', oldBg);
          root.style.setProperty('--sidebar-color', oldSidebar);
          root.style.setProperty('--accent-color', oldAccent);
          root.style.setProperty('--highlight-color', oldHighlight);
          root.style.setProperty('--text-color', oldText);
          // إزالة العنصر المؤقت من الصفحة
          wrapper.remove();
          const imgData = canvas.toDataURL('image/png');
          const { jsPDF } = window.jspdf;
          // استخدم الوضع الأفقي للحصول على عرض أكبر للجدول والرسم
          const pdf = new jsPDF('l', 'pt', 'a4');
          const pageWidth = pdf.internal.pageSize.getWidth();
          const imgWidth = pageWidth;
          const imgHeight = canvas.height * pageWidth / canvas.width;
          pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
          const sheetName = (isAllSelected() ? 'All' : (selectedEvents.size === 1 ? Array.from(selectedEvents)[0] : ('Multiple_' + selectedEvents.size))).replace(/[\/:*?"<>|]+/g, '_');
          const fileName = 'alarm_' + sheetName + '.pdf';
          pdf.save(fileName);
        });
      }).catch(() => {
        showMessage('Failed to load the PDF export library. Please connect to the internet');
      });
    }

    // تحديث قسم التحليل لأعلى التوربينات حسب إجمالي المدة
    function updateAnalysis() {
  if (!dataset.length || !filteredData.length) {
    analysisSection.style.display = 'none';
    return;
  }
  const totals = {};
  const countTotals = {};
  let grandCount = 0;
  let grandDur = 0;

  function getEventName(row) {
    if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') return row[colMap.event].trim();
    if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') return row[colMap.subevent].trim();
    return '';
  }
  function getDur(row) {
    // Prefer Start/End so we can time‑clip with the current time filter
    if (colMap.start && colMap.end) {
      const { startDate, endDate } = parseRowDate(row);
      if (startDate && endDate) {
        if (globalStartFilter || globalEndFilter) {
          return overlapSeconds(startDate, endDate, globalStartFilter, globalEndFilter);
        }
        return (endDate.getTime() - startDate.getTime()) / 1000;
      }
    }
    // Fallback to Duration column
    if (colMap.duration && row[colMap.duration]) {
      const base = parseDuration(row[colMap.duration]);
      // If dates exist, still use them for accurate clipping
      if (globalStartFilter || globalEndFilter) {
        const { startDate, endDate } = parseRowDate(row);
        if (startDate && endDate) {
          return overlapSeconds(startDate, endDate, globalStartFilter, globalEndFilter);
        }
      }
      return base;
    }
    return 0;
}

  filteredData.forEach(row => {
    const evName = getEventName(row);
    if (!evName) return;
    if (!isAllSelected() && !selectedEvents.has(evName)) return;

    const rawDev = row[colMap.device];
    if (!rawDev) return;
    const dev = String(rawDev).trim();
    if (!dev || dev.toLowerCase() === 'unknown' || dev === 'غير معروف') return;

    const dur = getDur(row);
    totals[dev] = (totals[dev] || 0) + dur;
    countTotals[dev] = (countTotals[dev] || 0) + 1;
    grandCount++;
    grandDur += dur;
  });

  const entries = Object.entries(totals).sort((a,b) => b[1]-a[1]).slice(0, 15);
  if (!entries.length) {
    analysisSection.style.display = 'none';
    return;
  }

  const labels = [];
  const data = [];
  analysisCounts = [];
  analysisDurationsFormatted = [];
  entries.forEach(([dev,total]) => {
    labels.push(dev);
    data.push(total / 3600);
    analysisCounts.push(countTotals[dev] || 0);
    analysisDurationsFormatted.push(formatDuration(total));
  });

  // Update metrics
  if (typeof metricAlarm !== 'undefined') metricAlarm.textContent = currentAlarmLabel();
  if (typeof metricCount !== 'undefined') metricCount.textContent = String(grandCount);
  if (typeof metricDuration !== 'undefined') metricDuration.textContent = formatDuration(grandDur);

  loadChartJS().then(() => {
    const ctx = analysisChartCanvas.getContext('2d');
    if (analysisChart) analysisChart.destroy();

    // Darker gradient & thicker bars
    const grad = ctx.createLinearGradient(0, 0, 0, analysisChartCanvas.height || 200);
    grad.addColorStop(0, 'rgba(14,165,233,0.70)');
    grad.addColorStop(1, 'rgba(14,165,233,0.45)');

    // Custom plugin to draw values on top of bars
    const valueLabelPlugin = {
      id: 'valueLabel',
      afterDatasetsDraw(chart, args, pluginOptions) {
        const { ctx } = chart;
        const meta = chart.getDatasetMeta(0);
        ctx.save();
        ctx.fillStyle = '#0f172a';
        ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica Neue, Arial';
        ctx.textAlign = 'center';
        meta.data.forEach((bar, i) => {
          const txt = (analysisDurationsFormatted && analysisDurationsFormatted[i]) ? analysisDurationsFormatted[i] : (data[i].toFixed(1) + 'h');
          let y = bar.y - 6;
          if (y < 12) y = bar.y + 12; // avoid clipping if too high
          ctx.fillText(txt, bar.x, y);
        });
        ctx.restore();
      }
    };

    analysisChart = new Chart(ctx, {
      type: 'bar',
      data: { labels, datasets: [{
        label: 'Total Duration (hours)',
        data,
        backgroundColor: grad,
        borderColor: 'rgba(14,165,233,0.95)',
        borderWidth: 2,
        borderRadius: 10,
        maxBarThickness: 60,
        barPercentage: 0.95,
        categoryPercentage: 0.80,
        hoverBackgroundColor: 'rgba(14,165,233,0.90)',
        hoverBorderWidth: 2
      }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            beginAtZero: true,
            title: { display: true, text: 'Duration (hours)' },
            ticks: { color: '#0f172a', font: { size: 12 } },
            grid: { color: '#e5e7eb' }
          },
          x: {
            title: { display: true, text: 'Turbine' },
            ticks: { color: '#0f172a', font: { size: 12 } },
            grid: { display: false }
          }
        },
        plugins: {
          legend: { display: false },
          tooltip: {
            usePointStyle: true,
            callbacks: {
              title: (items) => {
                const it = items && items[0];
                return it ? ('Turbine: ' + it.label) : '';
              },
              beforeBody: () => 'Alarm: ' + currentAlarmLabel(),
              label: (ctx) => {
                const i = ctx.dataIndex;
                return 'Duration: ' + (analysisDurationsFormatted[i] || '');
              },
              afterLabel: (ctx) => {
                const i = ctx.dataIndex;
                return 'Occurrences: ' + (analysisCounts[i] || 0);
              }
            }
          }
        }
      },
      plugins: [valueLabelPlugin]
    });

    analysisSection.style.display = '';
    analysisImgBtn.style.display = 'inline-block';
    analysisPdfBtn.style.display = 'inline-block';
  }).catch(() => {
    analysisSection.style.display = 'none';
  });
}

    // تصدير قسم التحليل كصورة
    function exportAnalysisImage() {
      // Temporarily hide the analysis export buttons so they do not appear in the exported image
      const prevImgDisplay = analysisImgBtn.style.display;
      const prevPdfDisplay = analysisPdfBtn.style.display;
      analysisImgBtn.style.display = 'none';
      analysisPdfBtn.style.display = 'none';
      loadPDFLib().then(() => {
        window.html2canvas(analysisSection).then(canvas => {
          // Restore the buttons after capturing
          analysisImgBtn.style.display = prevImgDisplay;
          analysisPdfBtn.style.display = prevPdfDisplay;
          const link = document.createElement('a');
          link.download = 'analysis.png';
          link.href = canvas.toDataURL('image/png');
          link.click();
        });
      }).catch(() => {
        // Restore the buttons in case of failure
        analysisImgBtn.style.display = prevImgDisplay;
        analysisPdfBtn.style.display = prevPdfDisplay;
        showMessage('Failed to load the libraries required to export the image. Please connect to the internet');
      });
    }

    // تصدير قسم التحليل كـ PDF
    function exportAnalysisPDF() {
      // Temporarily hide the analysis export buttons so they do not appear in the exported PDF
      const prevImgDisplay = analysisImgBtn.style.display;
      const prevPdfDisplay = analysisPdfBtn.style.display;
      analysisImgBtn.style.display = 'none';
      analysisPdfBtn.style.display = 'none';
      loadPDFLib().then(() => {
        // استخدم scale أعلى للحصول على جودة أفضل
        window.html2canvas(analysisSection, { scale: 2 }).then(canvas => {
          // Restore the buttons after capturing
          analysisImgBtn.style.display = prevImgDisplay;
          analysisPdfBtn.style.display = prevPdfDisplay;
          const imgData = canvas.toDataURL('image/png');
          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF('p', 'pt', 'a4');
          const pageWidth = pdf.internal.pageSize.getWidth();
          const imgWidth = pageWidth;
          const imgHeight = canvas.height * pageWidth / canvas.width;
          pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
          pdf.save('analysis.pdf');
        });
      }).catch(() => {
        // Restore the buttons in case of failure
        analysisImgBtn.style.display = prevImgDisplay;
        analysisPdfBtn.style.display = prevPdfDisplay;
        showMessage('Failed to load the libraries required to export the PDF. Please connect to the internet');
      });
    }

    // معالجة رفع الملف
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      hideMessage();
      dataset = [];
      header = [];
      colMap = {};
      filteredData = [];
      events = [];
      selectedEvents = new Set(['__ALL__']);
      tableContainer.innerHTML = '';
  /* reveal export buttons once a table is present */
  try { exportBtn.style.display=''; exportExcelBtn.style.display=''; exportPdfBtn.style.display=''; } catch(_) {}

      selectedEventTitle.textContent = 'Alarm: ' + currentAlarmLabel();
      exportBtn.style.display = 'none';
      const ext = file.name.split('.').pop().toLowerCase();
      // دالة مساعدة لتحليل البيانات بعد القراءة
      function handleParsedResult(parsed) {
        header = parsed.header;
        dataset = parsed.data;
        if (!dataset.length) {
          showMessage('لا توجد صفوف في الملف.');
          return;
        }
        detectColumns();
        if (!colMap.device || !colMap.event || !colMap.category) {
          showMessage('لم يتم العثور على الأعمدة الأساسية (الجهاز، الإنذار، الفئة) في الملف.');
          return;
        }
        filtersDiv.style.display = 'block';
        filteredData = dataset.slice();
        buildCategoryFilters();
        updateFilteredData();
      }
      if (ext === 'csv' || ext === 'txt') {
        const reader = new FileReader();
        reader.onload = function(evt) {
          const text = evt.target.result;
          const parsed = parseCSV(text);
          handleParsedResult(parsed);
        };
        reader.onerror = function() {
          showMessage('حدث خطأ أثناء قراءة الملف.');
        };
        reader.readAsText(file);
      } else if (ext === 'xls' || ext === 'xlsx') {
        // حاول تحميل مكتبة XLSX من الإنترنت
        showMessage('جارٍ تحميل مكتبة Excel من الإنترنت...');
        loadXLSX().then(() => {
          const reader = new FileReader();
          reader.onload = function(evt) {
            try {
              const data = new Uint8Array(evt.target.result);
              const workbook = XLSX.read(data, { type: 'array' });
              const sheetName = workbook.SheetNames[0];
              // حوّل أول شيت إلى CSV واستخدم المحلل نفسه
              const csv = XLSX.utils.sheet_to_csv(workbook.Sheets[sheetName], { FS: ',' });
              const parsed = parseCSV(csv);
              hideMessage();
              handleParsedResult(parsed);
            } catch (err) {
              showMessage('Failed to parse the Excel file. Please save the file as CSV or ensure the file is valid.');
            }
          };
          reader.onerror = function() {
            showMessage('حدث خطأ أثناء قراءة الملف.');
          };
          reader.readAsArrayBuffer(file);
        }).catch(() => {
          showMessage('Failed to load the Excel library from the internet. Please save the file as CSV or ensure you are connected to the internet.');
        });
      } else {
        showMessage('نوع ملف غير مدعوم.');
      }
    });

    // تحميل مكتبة XLSX من CDN عند الحاجة
    function loadXLSX() {
      return new Promise((resolve, reject) => {
        if (window.XLSX) {
          return resolve();
        }
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
        script.onload = () => resolve();
        script.onerror = () => reject();
        document.head.appendChild(script);
      });
    }

    // أحداث الأزرار السريعة
    todayBtn.addEventListener('click', () => {
      const now = new Date();
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const todayStr = yyyy + '-' + mm + '-' + dd;
      startDateInput.value = todayStr;
      endDateInput.value = todayStr;
      startTimeInput.value = '00:00';
      endTimeInput.value = '23:59';
      updateFilteredData();
    });
    yesterdayBtn.addEventListener('click', () => {
      const now = new Date();
      now.setDate(now.getDate() - 1);
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const yStr = yyyy + '-' + mm + '-' + dd;
      startDateInput.value = yStr;
      endDateInput.value = yStr;
      startTimeInput.value = '00:00';
      endTimeInput.value = '23:59';
      updateFilteredData();
    });
    last24Btn.addEventListener('click', () => {
      const now = new Date();
      const end = now;
      const start = new Date(now.getTime() - 24 * 3600 * 1000);
      const formatDate = (d) => {
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const dd = String(d.getDate()).padStart(2, '0');
        return yyyy + '-' + mm + '-' + dd;
      };
      const formatTime = (d) => {
        const hh = String(d.getHours()).padStart(2, '0');
        const mn = String(d.getMinutes()).padStart(2, '0');
        return hh + ':' + mn;
      };
      startDateInput.value = formatDate(start);
      endDateInput.value = formatDate(end);
      startTimeInput.value = formatTime(start);
      endTimeInput.value = formatTime(end);
      updateFilteredData();
    });
    clearFilterBtn.addEventListener('click', () => {
      startDateInput.value = '';
      endDateInput.value = '';
      startTimeInput.value = '';
      endTimeInput.value = '';
      updateFilteredData();
    });

    // عند تغيير المدخلات الزمنية يدويًا
    startDateInput.addEventListener('change', updateFilteredData);
    endDateInput.addEventListener('change', updateFilteredData);
    startTimeInput.addEventListener('change', updateFilteredData);
    endTimeInput.addEventListener('change', updateFilteredData);

    // زر التصدير
    exportBtn.addEventListener('click', exportCurrentTable);

    // زر التصدير إلى Excel
    exportExcelBtn.addEventListener('click', exportCurrentTableExcel);
    // زر التصدير إلى PDF
    exportPdfBtn.addEventListener('click', exportCurrentTablePDF);

    // أزرار تصدير التحليل
    analysisImgBtn.addEventListener('click', exportAnalysisImage);
    analysisPdfBtn.addEventListener('click', exportAnalysisPDF);
  
// === Full table PDF export (print-friendly, multi-page, no external libs) ===
(function setupPrintPDF(){
  try {
    window.__ensurePdfButton && window.__ensurePdfButton();
    const original = document.getElementById('export-pdf-btn');
    if (!original) return;
    // Replace node to remove any existing event listeners (so it won't trigger twice)
    const btn = original.cloneNode(true);
    original.parentNode.replaceChild(btn, original);
    btn.style.display = ''; // ensure visible

    // No-op any legacy PDF export function if it exists
    try { window.exportCurrentTablePDF = function(){ /* overridden: single-print only */ }; } catch(_){}

    // Helper to build printable HTML (as before)
    function buildPrintableHTML(tableHtml) {
      const title = (document.getElementById('selected-event-title')?.textContent || 'Exported Table').trim();
      const styles = `
        <style>
          @page { size: A4 landscape; margin: 12mm; }
          html, body { font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; color: #0f172a; }
          h1 { font-size: 16px; margin: 0 0 8px 0; }
          .meta { font-size: 11px; color: #475569; margin: 0 0 10px 0; }
          table { width: 100%; border-collapse: collapse; table-layout: fixed; }
          thead { display: table-header-group; }
          tfoot { display: table-footer-group; }
          th, td { border: 1px solid #e5e7eb; padding: 6px 8px; vertical-align: top; word-break: break-word; }
          th { background: #0f172a; color: #fff; font-weight: 700; font-size: 12px; }
          td { font-size: 11px; }
          tr { page-break-inside: avoid; }
          .footer { font-size: 10px; color: #64748b; margin-top: 8px; }
        </style>`;
      const now = new Date();
      const meta = `Printed on: ${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
      return `<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />${styles}<title>${title}</title></head>
<body>
  <h1>${title}</h1>
  <div class="meta">${meta}</div>
  ${tableHtml}
  <div class="footer">Exported from AWS Analysis dashboard</div>
  <script>
    window.addEventListener('afterprint', () => window.close());
    window.addEventListener('load', () => setTimeout(() => window.print(), 100));
  <\/script>
</body>
</html>`;
    }

    function exportTableToPDF() {
      const table = document.querySelector('#table-container table');
      if (!table) { alert('No table to export yet.'); return; }
      const clone = table.cloneNode(true);
      clone.querySelectorAll('button, input, select, .no-print').forEach(el => el.remove());
      const wrapper = document.createElement('div');
      const t = document.createElement('table');
      t.innerHTML = clone.innerHTML;
      wrapper.appendChild(t);
      const docHtml = buildPrintableHTML(wrapper.innerHTML);
      const win = window.open('', '_blank');
      win.document.open();
      win.document.write(docHtml);
      win.document.close();
    }

    // Single handler (after replacing node there are no other listeners)
    btn.addEventListener('click', exportTableToPDF);
  } catch (e) {
    console.error('Failed to set up PDF export:', e);
  }
})();

// === Ensure Export PDF button exists & stays visible ===
(function ensurePdfButton(){
  function makeBtn(){
    const b = document.createElement('button');
    b.id = 'export-pdf-btn';
    b.textContent = 'Export table (PDF)';
    b.style.marginRight = '8px';
    return b;
  }
  function findContainer(){
    // Prefer the same row as CSV/Excel buttons
    const csv = document.getElementById('export-btn');
    const xls = document.getElementById('export-excel-btn');
    if (csv && csv.parentElement) return csv.parentElement;
    if (xls && xls.parentElement) return xls.parentElement;
    // fallback: append after table container
    return document.getElementById('table-container') || document.body;
  }
  function ensure(){
    let btn = document.getElementById('export-pdf-btn');
    if (!btn){
      const parent = findContainer();
      btn = makeBtn();
      parent && parent.appendChild(btn);
    }
    // Always force visible
    btn.removeAttribute('hidden');
    btn.style.display = '';
    btn.classList.remove('hidden');
  }
  document.addEventListener('DOMContentLoaded', ensure);
  // Also try after each render tick
  window.addEventListener('load', ensure);
  // Expose for manual calls (e.g., after updateTable)
  window.__ensurePdfButton = ensure;
})();


// === Strong ensure for Export PDF button (create+show+bind single handler) ===
(function ensurePdfButtonStrong(){
  function findButtonsContainer(){
    const csv = document.getElementById('export-btn');
    if (csv && csv.parentElement) return csv.parentElement;
    const wrap = document.querySelector('#table-container')?.parentElement || document.body;
    return wrap;
  }
  function ensureButton(){
    let btn = document.getElementById('export-pdf-btn');
    if (!btn){
      btn = document.createElement('button');
      btn.id = 'export-pdf-btn';
      btn.textContent = 'Export table (PDF)';
      findButtonsContainer().appendChild(btn);
    }
    // Force visible regardless of prior CSS
    btn.style.display = 'inline-block';
    btn.removeAttribute('hidden');
    btn.classList.remove('hidden');
    // A bit of spacing like the other buttons
    btn.style.marginLeft = '8px';
    btn.style.marginRight = '0';
    return btn;
  }
  window.__ensurePdfButton = ensureButton;
  document.addEventListener('DOMContentLoaded', ensureButton);
  window.addEventListener('load', ensureButton);
})();

// === Single-print PDF (table + chart) ===
(function setupPrintPDFOnce(){
  function buildPrintableHTML(tableHtml, chartDataUrl, metrics){
    const title = (document.getElementById('selected-event-title')?.textContent || 'Exported Table').trim();
    const styles = `
      <style>
        @page { size: A4 landscape; margin: 12mm; }
        html, body { font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; color: #0f172a; }
        h1 { font-size: 16px; margin: 0 0 8px 0; }
        h2 { font-size: 14px; margin: 14px 0 8px 0; }
        .meta { font-size: 11px; color: #475569; margin: 0 0 10px 0; }
        table { width: 100%; border-collapse: collapse; table-layout: fixed; }
        thead { display: table-header-group; }
        tfoot { display: table-footer-group; }
        th, td { border: 1px solid #e5e7eb; padding: 6px 8px; vertical-align: top; word-break: break-word; }
        th { background: #0f172a; color: #fff; font-weight: 700; font-size: 12px; }
        td { font-size: 11px; }
        tr { page-break-inside: avoid; }
        .metrics { display:flex; flex-wrap:wrap; gap:10px; font-size: 11px; color:#334155; }
        .metric { padding: 2px 8px; border:1px solid #e5e7eb; border-radius: 999px; }
        .footer { font-size: 10px; color: #64748b; margin-top: 8px; }
        .chart-wrap { page-break-inside: avoid; margin-top: 8px; }
        .chart-wrap img { width: 100%; height: auto; }
      </style>`;
    const now = new Date();
    const meta = `Printed on: ${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;

    const chartBlock = chartDataUrl ? `
      <h2>Analysis Chart</h2>
      <div class="metrics">
        ${metrics.alarm ? `<div class="metric">Alarm: <strong>${metrics.alarm}</strong></div>` : ''}
        ${metrics.count ? `<div class="metric">Occurrences: <strong>${metrics.count}</strong></div>` : ''}
        ${metrics.duration ? `<div class="metric">Total Duration: <strong>${metrics.duration}</strong></div>` : ''}
      </div>
      <div class="chart-wrap">
        <img alt="Analysis Chart" src="${chartDataUrl}"/>
      </div>` : '';

    return `<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />${styles}<title>${title}</title></head>
<body>
  <h1>${title}</h1>
  <div class="meta">${meta}</div>
  ${tableHtml}
  ${chartBlock}
  <div class="footer">Exported from AWS Analysis dashboard</div>
  <script>
    window.addEventListener('afterprint', () => window.close());
    window.addEventListener('load', () => setTimeout(() => window.print(), 100));
  <\/script>
</body>
</html>`;
  }

  function exportTableAndChartToPDF(){
    const table = document.querySelector('#table-container table');
    if (!table) { alert('No table to export yet.'); return; }
    // Clone current table
    const clone = table.cloneNode(true);
    const wrapper = document.createElement('div');
    const tbl = document.createElement('table');
    tbl.innerHTML = clone.innerHTML;
    wrapper.appendChild(tbl);

    // Try to capture chart canvas
    const canvas = document.getElementById('analysis-chart');
    let chartDataUrl = '';
    try {
      if (canvas && canvas.width && canvas.height) {
        chartDataUrl = canvas.toDataURL('image/png');
      }
    } catch (_) {}

    // Metrics
    const metrics = {
      alarm: (document.getElementById('metric-alarm')?.textContent || '').trim(),
      count: (document.getElementById('metric-count')?.textContent || '').trim(),
      duration: (document.getElementById('metric-duration')?.textContent || '').trim(),
    };

    const docHtml = buildPrintableHTML(wrapper.innerHTML, chartDataUrl, metrics);
    const win = window.open('', '_blank');
    win.document.open();
    win.document.write(docHtml);
    win.document.close();
  }

  function bindOnce(){
    // make sure button exists then bind single listener
    const ensureBtn = window.__ensurePdfButton || (()=>{});
    const btn = ensureBtn();
    if (!btn) return;
    // Remove any previous listeners by replacing the node
    const cloneBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(cloneBtn, btn);
    cloneBtn.addEventListener('click', exportTableAndChartToPDF);
  }

  // bind on DOM ready + after table renders
  document.addEventListener('DOMContentLoaded', bindOnce);
  window.addEventListener('load', bindOnce);
  // Expose to call after updateTable()
  window.__bindPdfExport = bindOnce;
})();

// === Robust CSV/Excel export: use the currently visible table ===
(function ensureDOMTableExports(){
  // Convert the on-screen table to a 2D array (AOA)
  function getCurrentTableAOA(){
    const table = document.querySelector('#table-container table');
    if (!table) return [];
    const aoa = [];
    const ths = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    if (ths.length) aoa.push(ths);
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach(tr => {
      const tds = Array.from(tr.children).map(td => (td.textContent || '').trim());
      aoa.push(tds);
    });
    return aoa;
  }

  // CSV export straight from the DOM table
  function exportCSVFromDOM(){
    const aoa = getCurrentTableAOA();
    if (!aoa || aoa.length === 0) {
      alert('No table data to export.');
      return;
    }
    function csvEscape(s){
      s = String(s).replace(/\r?\n/g, ' ').replace(/\r/g, ' ');
      if (/[\",;\t]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
      return s;
    }
    const csv = aoa.map(row => row.map(csvEscape).join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'alarm_table.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
  }

  // Excel export straight from DOM table (requires XLSX; load if needed)
  function exportExcelFromDOM(){
    const aoa = getCurrentTableAOA();
    if (!aoa || aoa.length === 0) {
      alert('No table data to export.');
      return;
    }
    function _go(){
      const ws = XLSX.utils.aoa_to_sheet(aoa);
      // Auto width
      const colWidths = aoa[0].map((_, ci) => {
        let w = 10;
        for (let ri=0; ri<aoa.length; ri++){
          const v = (aoa[ri][ci] ?? '').toString();
          w = Math.max(w, Math.min(60, v.length + 2));
        }
        return { wch: w };
      });
      ws['!cols'] = colWidths;
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Alarm Table');
      XLSX.writeFile(wb, 'alarm_table.xlsx');
    }
    if (typeof XLSX === 'undefined'){
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
      s.onload = _go;
      s.onerror = () => alert('Failed to load Excel library. Please connect to the internet.');
      document.head.appendChild(s);
    } else {
      _go();
    }
  }

  // Rebind buttons to these robust exporters (single listeners)
  function bindExportButtons(){
    const csvBtn = document.getElementById('export-btn');
    const xlsBtn = document.getElementById('export-excel-btn');
    if (csvBtn){
      const clone = csvBtn.cloneNode(true);
      csvBtn.parentNode.replaceChild(clone, csvBtn);
      clone.addEventListener('click', exportCSVFromDOM);
    }
    if (xlsBtn){
      const clone = xlsBtn.cloneNode(true);
      xlsBtn.parentNode.replaceChild(clone, xlsBtn);
      clone.addEventListener('click', exportExcelFromDOM);
    }
  }

  document.addEventListener('DOMContentLoaded', bindExportButtons);
  window.addEventListener('load', bindExportButtons);
  // Make callable after each table rebuild
  window.__bindDomTableExports = bindExportButtons;
})();


// === Ensure ALL export buttons exist & are visible in one row ===
(function ensureAllExportButtons(){
  function findButtonsContainer(){
    // Prefer the same toolbar the file already uses (below the table)
    const group = document.querySelector('#table-container + div, #table-container ~ div');
    if (group && group.querySelector('button')) return group;
    // Fallback: create a group under the table
    let wrap = document.getElementById('table-container');
    if (!wrap) wrap = document.body;
    let g = wrap.nextElementSibling;
    if (!g || g.tagName !== 'DIV') { g = document.createElement('div'); wrap.parentNode.insertBefore(g, wrap.nextSibling); }
    g.style.display = 'flex'; g.style.flexWrap = 'wrap'; g.style.gap = '8px'; g.style.marginTop = '8px';
    return g;
  }
  function ensureBtn(id, label){
    let b = document.getElementById(id);
    if (!b){
      b = document.createElement('button');
      b.id = id; b.textContent = label;
      b.style.padding = '6px 12px';
      b.style.borderRadius = '10px';
      b.style.border = '1px solid #e5e7eb';
      b.style.fontWeight = '600';
      b.style.cursor = 'pointer';
      findButtonsContainer().appendChild(b);
    }
    b.style.display = 'inline-block';
    b.removeAttribute('hidden');
    b.classList.remove('hidden');
    return b;
  }
  function ensureAll(){
    const a = ensureBtn('export-btn', 'Export table (CSV)');
    const b = ensureBtn('export-excel-btn', 'Export table (Excel)');
    const c = ensureBtn('export-pdf-btn', 'Export table (PDF)');
    return {csv:a, xls:b, pdf:c};
  }
  window.__ensureAllExportButtons = ensureAll;
  document.addEventListener('DOMContentLoaded', ensureAll);
  window.addEventListener('load', ensureAll);
})();

// === Robust exporters that use the VISIBLE table (DOM) ===
(function bindDomExporters(){
  function getCurrentTableAOA(){
    const table = document.querySelector('#table-container table');
    if (!table) return [];
    const aoa = [];
    const ths = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    if (ths.length) aoa.push(ths);
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach(tr => aoa.push(Array.from(tr.children).map(td => (td.textContent||'').trim())));
    return aoa;
  }
  function exportCSV(){
    const aoa = getCurrentTableAOA();
    if (!aoa.length) { alert('No table data to export.'); return; }
    const esc = s => {
      s = String(s).replace(/\r?\n/g,' ').replace(/\r/g,' ');
      return /[\",;\t]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
    };
    const csv = aoa.map(r => r.map(esc).join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'alarm_table.csv';
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(a.href);
  }
  function exportExcel(){
    const aoa = getCurrentTableAOA();
    if (!aoa.length) { alert('No table data to export.'); return; }
    function go(){
      const ws = XLSX.utils.aoa_to_sheet(aoa);
      ws['!cols'] = aoa[0].map((_,i)=>({wch: Math.min(60, Math.max(10, Math.max(...aoa.map(r=>(r[i]||'').toString().length+2))))}));
      const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, 'Alarm Table'); XLSX.writeFile(wb, 'alarm_table.xlsx');
    }
    if (typeof XLSX==='undefined'){ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js'; s.onload=go; s.onerror=()=>alert('Failed to load Excel library.'); document.head.appendChild(s); }
    else go();
  }
  function exportPDF(){
    // If a dedicated PDF exporter exists, call it; else quick fallback prints table only
    if (typeof exportTableAndChartToPDF === 'function') return exportTableAndChartToPDF();
    const table = document.querySelector('#table-container table'); if (!table){ alert('No table to export.'); return; }
    const clone = table.cloneNode(true); const wrap = document.createElement('div'); const tbl = document.createElement('table'); tbl.innerHTML=clone.innerHTML; wrap.appendChild(tbl);
    const html = `<!doctype html><html><head><meta charset="utf-8"><style>@page{size:A4 landscape;margin:12mm} table{width:100%;border-collapse:collapse} th,td{border:1px solid #e5e7eb;padding:6px 8px} thead{display:table-header-group}</style></head><body>${wrap.innerHTML}<script>addEventListener('load',()=>setTimeout(()=>print(),50));<\/script></body></html>`;
    const w = window.open('','_blank'); w.document.open(); w.document.write(html); w.document.close();
  }
  function bind(){
    const {csv, xls, pdf} = (window.__ensureAllExportButtons && window.__ensureAllExportButtons()) || {};
    if (csv){ const c=csv.cloneNode(true); csv.parentNode.replaceChild(c, csv); c.addEventListener('click', exportCSV); }
    if (xls){ const x=xls.cloneNode(true); xls.parentNode.replaceChild(x, xls); x.addEventListener('click', exportExcel); }
    if (pdf){ const p=pdf.cloneNode(true); pdf.parentNode.replaceChild(p, pdf); p.addEventListener('click', exportPDF); }
  }
  window.__bindDomExportsAll = bind;
  document.addEventListener('DOMContentLoaded', bind);
  window.addEventListener('load', bind);
})();
</script>
<footer id="page-footer" role="contentinfo" aria-label="Credits">
  <div class="credit">Designed by <strong>Mohamed Lasheen</strong></div>
</footer>
</body>
</html>